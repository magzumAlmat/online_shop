{"ast":null,"code":"import { MixedType } from './MixedType';\nexport class ArrayType extends MixedType {\n  constructor(errorMessage) {\n    super('array');\n    super.pushRule({\n      onValid: v => Array.isArray(v),\n      errorMessage: errorMessage || this.locale.type\n    });\n  }\n\n  rangeLength(minLength, maxLength) {\n    let errorMessage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.locale.rangeLength;\n    super.pushRule({\n      onValid: value => value.length >= minLength && value.length <= maxLength,\n      errorMessage,\n      params: {\n        minLength,\n        maxLength\n      }\n    });\n    return this;\n  }\n\n  minLength(minLength) {\n    let errorMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.locale.minLength;\n    super.pushRule({\n      onValid: value => value.length >= minLength,\n      errorMessage,\n      params: {\n        minLength\n      }\n    });\n    return this;\n  }\n\n  maxLength(maxLength) {\n    let errorMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.locale.maxLength;\n    super.pushRule({\n      onValid: value => value.length <= maxLength,\n      errorMessage,\n      params: {\n        maxLength\n      }\n    });\n    return this;\n  }\n\n  unrepeatable() {\n    let errorMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.locale.unrepeatable;\n    super.pushRule({\n      onValid: items => {\n        const hash = {};\n\n        for (const i in items) {\n          if (hash[items[i]]) {\n            return false;\n          }\n\n          hash[items[i]] = true;\n        }\n\n        return true;\n      },\n      errorMessage\n    });\n    return this;\n  }\n\n  of(type) {\n    super.pushRule({\n      onValid: (items, data, filedName) => {\n        const checkResults = items.map((value, index) => {\n          const name = Array.isArray(filedName) ? [...filedName, `[${index}]`] : [filedName, `[${index}]`];\n          return type.check(value, data, name);\n        });\n        const hasError = !!checkResults.find(item => item === null || item === void 0 ? void 0 : item.hasError);\n        return {\n          hasError,\n          array: checkResults\n        };\n      }\n    });\n    return this;\n  }\n\n}\nexport default function getArrayType(errorMessage) {\n  return new ArrayType(errorMessage);\n}","map":{"version":3,"sources":["../src/ArrayType.ts"],"names":[],"mappings":"AAAA,SAAS,SAAT,QAA0B,aAA1B;AAIA,OAAM,MAAO,SAAP,SAA+D,SAA/D,CAKL;EACC,WAAA,CAAY,YAAZ,EAAqC;IACnC,MAAM,OAAN;IACA,MAAM,QAAN,CAAe;MACb,OAAO,EAAE,CAAC,IAAI,KAAK,CAAC,OAAN,CAAc,CAAd,CADD;MAEb,YAAY,EAAE,YAAY,IAAI,KAAK,MAAL,CAAY;IAF7B,CAAf;EAID;;EAED,WAAW,CACT,SADS,EAET,SAFS,EAGyC;IAAA,IAAlD,YAAkD,uEAAvB,KAAK,MAAL,CAAY,WAAW;IAElD,MAAM,QAAN,CAAe;MACb,OAAO,EAAG,KAAD,IAAqB,KAAK,CAAC,MAAN,IAAgB,SAAhB,IAA6B,KAAK,CAAC,MAAN,IAAgB,SAD9D;MAEb,YAFa;MAGb,MAAM,EAAE;QAAE,SAAF;QAAa;MAAb;IAHK,CAAf;IAKA,OAAO,IAAP;EACD;;EAED,SAAS,CAAC,SAAD,EAAoE;IAAA,IAAhD,YAAgD,uEAArB,KAAK,MAAL,CAAY,SAAS;IAC3E,MAAM,QAAN,CAAe;MACb,OAAO,EAAE,KAAK,IAAI,KAAK,CAAC,MAAN,IAAgB,SADrB;MAEb,YAFa;MAGb,MAAM,EAAE;QAAE;MAAF;IAHK,CAAf;IAMA,OAAO,IAAP;EACD;;EAED,SAAS,CAAC,SAAD,EAAoE;IAAA,IAAhD,YAAgD,uEAArB,KAAK,MAAL,CAAY,SAAS;IAC3E,MAAM,QAAN,CAAe;MACb,OAAO,EAAE,KAAK,IAAI,KAAK,CAAC,MAAN,IAAgB,SADrB;MAEb,YAFa;MAGb,MAAM,EAAE;QAAE;MAAF;IAHK,CAAf;IAKA,OAAO,IAAP;EACD;;EAED,YAAY,GAAoD;IAAA,IAAnD,YAAmD,uEAAxB,KAAK,MAAL,CAAY,YAAY;IAC9D,MAAM,QAAN,CAAe;MACb,OAAO,EAAE,KAAK,IAAG;QACf,MAAM,IAAI,GAAgB,EAA1B;;QACA,KAAK,MAAM,CAAX,IAAgB,KAAhB,EAAuB;UACrB,IAAI,IAAI,CAAC,KAAK,CAAC,CAAD,CAAN,CAAR,EAAoB;YAClB,OAAO,KAAP;UACD;;UACD,IAAI,CAAC,KAAK,CAAC,CAAD,CAAN,CAAJ,GAAiB,IAAjB;QACD;;QACD,OAAO,IAAP;MACD,CAVY;MAWb;IAXa,CAAf;IAcA,OAAO,IAAP;EACD;;EAED,EAAE,CAAC,IAAD,EAAkC;IAClC,MAAM,QAAN,CAAe;MACb,OAAO,EAAE,CAAC,KAAD,EAAQ,IAAR,EAAc,SAAd,KAA2B;QAClC,MAAM,YAAY,GAAG,KAAK,CAAC,GAAN,CAAU,CAAC,KAAD,EAAQ,KAAR,KAAiB;UAC9C,MAAM,IAAI,GAAG,KAAK,CAAC,OAAN,CAAc,SAAd,IACT,CAAC,GAAG,SAAJ,EAAe,IAAI,KAAK,GAAxB,CADS,GAET,CAAC,SAAD,EAAY,IAAI,KAAK,GAArB,CAFJ;UAIA,OAAO,IAAI,CAAC,KAAL,CAAW,KAAX,EAAkB,IAAlB,EAAwB,IAAxB,CAAP;QACD,CANoB,CAArB;QAOA,MAAM,QAAQ,GAAG,CAAC,CAAC,YAAY,CAAC,IAAb,CAAkB,IAAI,IAAI,IAAI,KAAA,IAAJ,IAAA,IAAI,KAAA,KAAA,CAAJ,GAAI,KAAA,CAAJ,GAAA,IAAI,CAAE,QAAhC,CAAnB;QAEA,OAAO;UACL,QADK;UAEL,KAAK,EAAE;QAFF,CAAP;MAID;IAfY,CAAf;IAkBA,OAAO,IAAP;EACD;;AA/EF;AAkFD,eAAc,SAAU,YAAV,CAAmD,YAAnD,EAAmE;EAC/E,OAAO,IAAI,SAAJ,CAA2B,YAA3B,CAAP;AACD","sourceRoot":"","sourcesContent":["import { MixedType } from './MixedType';\nexport class ArrayType extends MixedType {\n    constructor(errorMessage) {\n        super('array');\n        super.pushRule({\n            onValid: v => Array.isArray(v),\n            errorMessage: errorMessage || this.locale.type\n        });\n    }\n    rangeLength(minLength, maxLength, errorMessage = this.locale.rangeLength) {\n        super.pushRule({\n            onValid: (value) => value.length >= minLength && value.length <= maxLength,\n            errorMessage,\n            params: { minLength, maxLength }\n        });\n        return this;\n    }\n    minLength(minLength, errorMessage = this.locale.minLength) {\n        super.pushRule({\n            onValid: value => value.length >= minLength,\n            errorMessage,\n            params: { minLength }\n        });\n        return this;\n    }\n    maxLength(maxLength, errorMessage = this.locale.maxLength) {\n        super.pushRule({\n            onValid: value => value.length <= maxLength,\n            errorMessage,\n            params: { maxLength }\n        });\n        return this;\n    }\n    unrepeatable(errorMessage = this.locale.unrepeatable) {\n        super.pushRule({\n            onValid: items => {\n                const hash = {};\n                for (const i in items) {\n                    if (hash[items[i]]) {\n                        return false;\n                    }\n                    hash[items[i]] = true;\n                }\n                return true;\n            },\n            errorMessage\n        });\n        return this;\n    }\n    of(type) {\n        super.pushRule({\n            onValid: (items, data, filedName) => {\n                const checkResults = items.map((value, index) => {\n                    const name = Array.isArray(filedName)\n                        ? [...filedName, `[${index}]`]\n                        : [filedName, `[${index}]`];\n                    return type.check(value, data, name);\n                });\n                const hasError = !!checkResults.find(item => item === null || item === void 0 ? void 0 : item.hasError);\n                return {\n                    hasError,\n                    array: checkResults\n                };\n            }\n        });\n        return this;\n    }\n}\nexport default function getArrayType(errorMessage) {\n    return new ArrayType(errorMessage);\n}\n//# sourceMappingURL=ArrayType.js.map"]},"metadata":{},"sourceType":"module"}