{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.getLoginMethodAndParams = getLoginMethodAndParams, exports.getReauthenticateMethodAndParams = getReauthenticateMethodAndParams, exports.authIsReady = authIsReady, exports.createAuthIsReady = createAuthIsReady, exports.updateProfileOnRTDB = updateProfileOnRTDB, exports.updateProfileOnFirestore = updateProfileOnFirestore, exports.setupPresence = setupPresence;\n\nvar _capitalize2 = _interopRequireDefault(require(\"lodash/capitalize\")),\n    _constants = require(\"../constants\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction createAuthProvider(firebase, providerName, scopes) {\n  var lowerCaseProviderName = providerName.toLowerCase();\n\n  if (\"microsoft.com\" === lowerCaseProviderName || \"apple.com\" === lowerCaseProviderName || \"yahoo.com\" === lowerCaseProviderName) {\n    var _provider = new firebase.auth.OAuthProvider(providerName);\n\n    return _provider;\n  }\n\n  var capitalProviderName = \"\".concat((0, _capitalize2.default)(providerName), \"AuthProvider\");\n  if (!firebase.auth[capitalProviderName]) throw new Error(\"\".concat(providerName, \" is not a valid auth provider for your firebase instance. If using react-native, use a RN specific auth library.\"));\n  var provider = new firebase.auth[capitalProviderName](),\n      customAuthParameters = firebase._.config.customAuthParameters;\n  return (customAuthParameters && customAuthParameters[providerName] && provider.setCustomParameters(customAuthParameters[providerName]), \"twitter\" === lowerCaseProviderName || \"function\" != typeof provider.addScope) ? provider : (provider.addScope(\"email\"), scopes && (Array.isArray(scopes) && scopes.forEach(function (scope) {\n    provider.addScope(scope);\n  }), (\"string\" == typeof scopes || scopes instanceof String) && provider.addScope(scopes)), provider);\n}\n\nfunction getLoginMethodAndParams(firebase, credentials) {\n  var email = credentials.email,\n      password = credentials.password,\n      provider = credentials.provider,\n      type = credentials.type,\n      token = credentials.token,\n      scopes = credentials.scopes,\n      phoneNumber = credentials.phoneNumber,\n      applicationVerifier = credentials.applicationVerifier,\n      credential = credentials.credential;\n\n  if (credential) {\n    var credentialAuth = firebase.auth().signInAndRetrieveDataWithCredential;\n    return credentialAuth ? {\n      method: \"signInAndRetrieveDataWithCredential\",\n      params: [credential]\n    } : {\n      method: \"signInWithCredential\",\n      params: [credential]\n    };\n  }\n\n  if (provider) {\n    if (-1 === _constants.supportedAuthProviders.indexOf(provider.toLowerCase())) throw new Error(\"\".concat(provider, \" is not a valid Auth Provider\"));\n    if (token) throw new Error(\"provider with token no longer supported, use credential parameter instead\");\n    var authProvider = createAuthProvider(firebase, provider, scopes);\n    return \"popup\" === type ? {\n      method: \"signInWithPopup\",\n      params: [authProvider]\n    } : {\n      method: \"signInWithRedirect\",\n      params: [authProvider]\n    };\n  }\n\n  if (token) {\n    var tokenAuth = firebase.auth().signInAndRetrieveDataWithCustomToken;\n    return tokenAuth ? {\n      method: \"signInAndRetrieveDataWithCustomToken\",\n      params: [token]\n    } : {\n      method: \"signInWithCustomToken\",\n      params: [token]\n    };\n  }\n\n  if (phoneNumber) {\n    if (!applicationVerifier) throw new Error(\"Application verifier is required for phone authentication\");\n    return {\n      method: \"signInWithPhoneNumber\",\n      params: [phoneNumber, applicationVerifier]\n    };\n  }\n\n  return firebase.auth().signInWithEmailAndPassword ? {\n    method: \"signInWithEmailAndPassword\",\n    params: [email, password]\n  } : {\n    method: \"signInAndRetrieveDataWithEmailAndPassword\",\n    params: [email, password]\n  };\n}\n\nfunction getReauthenticateMethodAndParams(firebase, credentials) {\n  var provider = credentials.provider,\n      type = credentials.type,\n      scopes = credentials.scopes,\n      phoneNumber = credentials.phoneNumber,\n      applicationVerifier = credentials.applicationVerifier,\n      credential = credentials.credential;\n\n  if (credential) {\n    var credentialAuth = firebase.auth().reauthenticateAndRetrieveDataWithCredential;\n    return credentialAuth ? {\n      method: \"reauthenticateAndRetrieveDataWithCredential\",\n      params: [credential]\n    } : {\n      method: \"reauthenticateWithCredential\",\n      params: [credential]\n    };\n  }\n\n  if (provider) {\n    if (-1 === _constants.supportedAuthProviders.indexOf(provider.toLowerCase())) throw new Error(\"\".concat(provider, \" is not a valid Auth Provider\"));\n    var authProvider = createAuthProvider(firebase, provider, scopes);\n    return \"popup\" === type ? {\n      method: \"reauthenticateWithPopup\",\n      params: [authProvider]\n    } : {\n      method: \"reauthenticateWithRedirect\",\n      params: [authProvider]\n    };\n  }\n\n  if (!applicationVerifier) throw new Error(\"Application verifier is required for phone authentication\");\n  return {\n    method: \"reauthenticateWithPhoneNumber\",\n    params: [phoneNumber, applicationVerifier]\n  };\n}\n\nfunction isAuthReady(store, stateName) {\n  var state = store.getState(),\n      firebaseState = stateName ? state[stateName] : state,\n      firebaseAuthState = firebaseState && firebaseState.auth;\n  if (!firebaseAuthState) throw new Error(\"The Firebase auth state could not be found in the store under the attribute '\".concat(stateName ? \"\".concat(stateName, \".\") : \"\", \"auth'. Make sure your react-redux-firebase reducer is correctly set in the store\"));\n  return firebaseState.auth.isLoaded;\n}\n\nfunction authIsReady(store) {\n  var stateName = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : \"firebase\";\n  return new Promise(function (resolve) {\n    if (isAuthReady(store, stateName)) resolve();else var unsubscribe = store.subscribe(function () {\n      isAuthReady(store, stateName) && (unsubscribe(), resolve());\n    });\n  });\n}\n\nfunction createAuthIsReady(store, config) {\n  return \"function\" == typeof config.authIsReady ? config.authIsReady(store, config) : authIsReady(store, config.firebaseStateName);\n}\n\nfunction updateProfileOnRTDB(firebase, profileUpdate) {\n  var _firebase$_ = firebase._,\n      config = _firebase$_.config,\n      authUid = _firebase$_.authUid,\n      profileRef = firebase.database().ref(\"\".concat(config.userProfile, \"/\").concat(authUid));\n  return profileRef.update(profileUpdate).then(function () {\n    return profileRef.once(\"value\");\n  });\n}\n\nfunction updateProfileOnFirestore(firebase, profileUpdate) {\n  var options = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : {},\n      _options$useSet = options.useSet,\n      _options$merge = options.merge,\n      firestore = firebase.firestore,\n      _firebase$_2 = firebase._,\n      config = _firebase$_2.config,\n      authUid = _firebase$_2.authUid,\n      profileRef = firestore().doc(\"\".concat(config.userProfile, \"/\").concat(authUid)),\n      profileUpdatePromise = !(void 0 !== _options$useSet) || _options$useSet ? profileRef.set(profileUpdate, {\n    merge: !(void 0 !== _options$merge) || _options$merge\n  }) : profileRef.update(profileUpdate);\n  return profileUpdatePromise.then(function () {\n    return profileRef.get();\n  });\n}\n\nfunction setupPresence(dispatch, firebase) {\n  if (firebase.database && firebase.database.ServerValue) {\n    var ref = firebase.database().ref(),\n        _firebase$_3 = firebase._,\n        _firebase$_3$config = _firebase$_3.config,\n        presence = _firebase$_3$config.presence,\n        sessions = _firebase$_3$config.sessions,\n        authUid = _firebase$_3.authUid,\n        amOnline = ref.child(\".info/connected\"),\n        onlineRef = ref.child(\"function\" == typeof presence ? presence(firebase.auth().currentUser, firebase) : presence).child(authUid),\n        sessionsRef = \"function\" == typeof sessions ? sessions(firebase.auth().currentUser, firebase) : sessions;\n    sessionsRef && (sessionsRef = ref.child(sessions)), amOnline.on(\"value\", function (snapShot) {\n      if (snapShot.val()) {\n        if (sessionsRef) {\n          dispatch({\n            type: _constants.actionTypes.SESSION_START,\n            payload: authUid\n          });\n          var session = sessionsRef.push({\n            startedAt: firebase.database.ServerValue.TIMESTAMP,\n            user: authUid\n          });\n          \"function\" == typeof session.setPriority && session.setPriority(authUid), session.child(\"endedAt\").onDisconnect().set(firebase.database.ServerValue.TIMESTAMP, function () {\n            dispatch({\n              type: _constants.actionTypes.SESSION_END\n            });\n          });\n        }\n\n        onlineRef.set(!0), onlineRef.onDisconnect().remove();\n      }\n    });\n  }\n}","map":{"version":3,"sources":["../../src/utils/auth.js"],"names":["lowerCaseProviderName","providerName","provider","firebase","capitalProviderName","customAuthParameters","scopes","Array","email","password","type","token","phoneNumber","applicationVerifier","credential","credentials","credentialAuth","method","params","authProvider","createAuthProvider","tokenAuth","state","store","firebaseState","stateName","firebaseAuthState","isLoaded","isAuthReady","resolve","unsubscribe","config","authIsReady","authUid","profileRef","options","firestore","profileUpdatePromise","merge","ref","presence","sessions","amOnline","onlineRef","sessionsRef","snapShot","dispatch","actionTypes","payload","session","startedAt","user"],"mappings":"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","sourcesContent":["import { capitalize } from 'lodash'\nimport { supportedAuthProviders, actionTypes } from '../constants'\n\n/**\n * @description Get correct login method and params order based on provided credentials\n * @param {object} firebase - Internal firebase object\n * @param {string} providerName - Name of Auth Provider (i.e. google, github, facebook, twitter)\n * @param {Array|string} scopes - List of scopes to add to auth provider\n * @returns {firebase.auth.AuthCredential} provider - Auth Provider\n * @private\n */\nfunction createAuthProvider(firebase, providerName, scopes) {\n  // TODO: Verify scopes are valid before adding\n  // TODO: Validate parameter inputs\n\n  const lowerCaseProviderName = providerName.toLowerCase()\n\n  if (\n    lowerCaseProviderName === 'microsoft.com' ||\n    lowerCaseProviderName === 'apple.com' ||\n    lowerCaseProviderName === 'yahoo.com'\n  ) {\n    const provider = new firebase.auth.OAuthProvider(providerName)\n    return provider\n  }\n\n  const capitalProviderName = `${capitalize(providerName)}AuthProvider`\n\n  // Throw if auth provider does not exist on Firebase instance\n  if (!firebase.auth[capitalProviderName]) {\n    throw new Error(\n      `${providerName} is not a valid auth provider for your firebase instance. If using react-native, use a RN specific auth library.`\n    )\n  }\n\n  const provider = new firebase.auth[capitalProviderName]()\n\n  // Custom Auth Parameters\n  // TODO: Validate parameter inputs\n  const { customAuthParameters } = firebase._.config\n  if (customAuthParameters && customAuthParameters[providerName]) {\n    provider.setCustomParameters(customAuthParameters[providerName])\n  }\n\n  // Handle providers without scopes\n  if (\n    lowerCaseProviderName === 'twitter' ||\n    typeof provider.addScope !== 'function'\n  ) {\n    return provider\n  }\n\n  // TODO: Verify scopes are valid before adding\n  provider.addScope('email')\n\n  if (scopes) {\n    if (Array.isArray(scopes)) {\n      scopes.forEach((scope) => {\n        provider.addScope(scope)\n      })\n    }\n    // Add single scope if it is a string\n    if (typeof scopes === 'string' || scopes instanceof String) {\n      provider.addScope(scopes)\n    }\n  }\n\n  return provider\n}\n\n/**\n * Get correct login method and params order based on provided\n * credentials\n * @param {object} firebase - Internal firebase object\n * @param {object} credentials - Login credentials\n * @param {string} credentials.email - Email to login with (only needed for\n * email login)\n * @param {string} credentials.password - Password to login with (only needed\n * for email login)\n * @param {string} credentials.provider - Provider name such as google, twitter\n * (only needed for 3rd party provider login)\n * @param {string} credentials.type - Popup or redirect (only needed for 3rd\n * party provider login)\n * @param {string} credentials.token - Custom or provider token\n * @param {firebase.auth.AuthCredential} credentials.credential - Custom or\n * provider token\n * @param {Array|string} credentials.scopes - Scopes to add to provider\n * (i.e. email)\n * @returns {object} Method and params for calling login\n * @private\n */\nexport function getLoginMethodAndParams(firebase, credentials) {\n  const {\n    email,\n    password,\n    provider,\n    type,\n    token,\n    scopes,\n    phoneNumber,\n    applicationVerifier,\n    credential\n  } = credentials\n  // Credential Auth\n  if (credential) {\n    // Attempt to use signInAndRetrieveDataWithCredential if it exists (see #467 for more info)\n    const credentialAuth = firebase.auth().signInAndRetrieveDataWithCredential\n\n    if (credentialAuth) {\n      return {\n        method: 'signInAndRetrieveDataWithCredential',\n        params: [credential]\n      }\n    }\n    return { method: 'signInWithCredential', params: [credential] }\n  }\n\n  // Provider Auth\n  if (provider) {\n    // Verify providerName is valid\n    if (supportedAuthProviders.indexOf(provider.toLowerCase()) === -1) {\n      throw new Error(`${provider} is not a valid Auth Provider`)\n    }\n    if (token) {\n      throw new Error(\n        'provider with token no longer supported, use credential parameter instead'\n      )\n    }\n    const authProvider = createAuthProvider(firebase, provider, scopes)\n    if (type === 'popup') {\n      return { method: 'signInWithPopup', params: [authProvider] }\n    }\n    return { method: 'signInWithRedirect', params: [authProvider] }\n  }\n\n  // Token Auth\n  if (token) {\n    // Check for new sign in method (see #484 for more info)\n    const tokenAuth = firebase.auth().signInAndRetrieveDataWithCustomToken\n\n    if (tokenAuth) {\n      return { method: 'signInAndRetrieveDataWithCustomToken', params: [token] }\n    }\n\n    return { method: 'signInWithCustomToken', params: [token] }\n  }\n\n  // Phone Number Auth\n  if (phoneNumber) {\n    if (!applicationVerifier) {\n      throw new Error(\n        'Application verifier is required for phone authentication'\n      )\n    }\n    return {\n      method: 'signInWithPhoneNumber',\n      params: [phoneNumber, applicationVerifier]\n    }\n  }\n\n  // Check for new sign in method (see #484 for more info)\n  // Note: usage of signInAndRetrieveDataWithEmailAndPassword is now a fallback since it is deprecated (see #484 for more info)\n  if (!firebase.auth().signInWithEmailAndPassword) {\n    return {\n      method: 'signInAndRetrieveDataWithEmailAndPassword',\n      params: [email, password]\n    }\n  }\n\n  // Email/Password Auth\n  return { method: 'signInWithEmailAndPassword', params: [email, password] }\n}\n\n/**\n * Get correct reauthenticate method and params order based on provided\n * credentials\n * @param {object} firebase - Internal firebase object\n * @param {object} credentials - Login credentials\n * @param {string} credentials.provider - Provider name such as google, twitter\n * (only needed for 3rd party provider login)\n * @param {string} credentials.type - Popup or redirect (only needed for 3rd\n * party provider login)\n * @param {firebase.auth.AuthCredential} credentials.credential - Custom or\n * provider token\n * @param {Array|string} credentials.scopes - Scopes to add to provider\n * (i.e. email)\n * @returns {object} Method and params for calling login\n * @private\n */\nexport function getReauthenticateMethodAndParams(firebase, credentials) {\n  const {\n    provider,\n    type,\n    scopes,\n    phoneNumber,\n    applicationVerifier,\n    credential\n  } = credentials\n  // Credential Auth\n  if (credential) {\n    // Attempt to use signInAndRetrieveDataWithCredential if it exists (see #467 for more info)\n    const credentialAuth = firebase.auth()\n      .reauthenticateAndRetrieveDataWithCredential\n\n    if (credentialAuth) {\n      return {\n        method: 'reauthenticateAndRetrieveDataWithCredential',\n        params: [credential]\n      }\n    }\n    return { method: 'reauthenticateWithCredential', params: [credential] }\n  }\n\n  // Provider Auth\n  if (provider) {\n    // Verify providerName is valid\n    if (supportedAuthProviders.indexOf(provider.toLowerCase()) === -1) {\n      throw new Error(`${provider} is not a valid Auth Provider`)\n    }\n    const authProvider = createAuthProvider(firebase, provider, scopes)\n    if (type === 'popup') {\n      return { method: 'reauthenticateWithPopup', params: [authProvider] }\n    }\n    return { method: 'reauthenticateWithRedirect', params: [authProvider] }\n  }\n\n  // Phone Number Auth\n  if (!applicationVerifier) {\n    throw new Error('Application verifier is required for phone authentication')\n  }\n  return {\n    method: 'reauthenticateWithPhoneNumber',\n    params: [phoneNumber, applicationVerifier]\n  }\n}\n\n/**\n * Returns a promise that completes when Firebase Auth is ready in the given\n * store using react-redux-firebase.\n * @param {object} store - The Redux store on which we want to detect if\n * Firebase auth is ready.\n * @param {string} [stateName='firebase'] - The attribute name of the\n * react-redux-firebase reducer when using multiple combined reducers.\n * 'firebase' by default. Set this to `null` to indicate that the\n * react-redux-firebase reducer is not in a combined reducer.\n * @returns {Promise} Resolves when Firebase auth is ready in the store.\n */\nfunction isAuthReady(store, stateName) {\n  const state = store.getState()\n  const firebaseState = stateName ? state[stateName] : state\n  const firebaseAuthState = firebaseState && firebaseState.auth\n  if (!firebaseAuthState) {\n    throw new Error(\n      `The Firebase auth state could not be found in the store under the attribute '${\n        stateName ? `${stateName}.` : ''\n      }auth'. Make sure your react-redux-firebase reducer is correctly set in the store`\n    )\n  }\n  return firebaseState.auth.isLoaded\n}\n\n/**\n * Returns a promise that completes when Firebase Auth is ready in the given\n * store using react-redux-firebase.\n * @param {object} store - The Redux store on which we want to detect if\n * Firebase auth is ready.\n * @param {string} [stateName='firebase'] - The attribute name of the react-redux-firebase\n * reducer when using multiple combined reducers. 'firebase' by default. Set\n * this to `null` to indicate that the react-redux-firebase reducer is not in a\n * combined reducer.\n * @returns {Promise} Resolve when Firebase auth is ready in the store.\n */\nexport function authIsReady(store, stateName = 'firebase') {\n  return new Promise((resolve) => {\n    if (isAuthReady(store, stateName)) {\n      resolve()\n    } else {\n      const unsubscribe = store.subscribe(() => {\n        if (isAuthReady(store, stateName)) {\n          unsubscribe()\n          resolve()\n        }\n      })\n    }\n  })\n}\n\n/**\n * Function that creates and authIsReady promise\n * @param {object} store - The Redux store on which we want to detect if\n * Firebase auth is ready.\n * @param {object} config - Config options for authIsReady\n * @param {string} config.authIsReady - Config options for authIsReady\n * @param {string} config.firebaseStateName - Config options for authIsReady\n * @returns {Promise} Resolves when Firebase auth is ready in the store.\n */\nexport function createAuthIsReady(store, config) {\n  return typeof config.authIsReady === 'function'\n    ? config.authIsReady(store, config)\n    : authIsReady(store, config.firebaseStateName)\n}\n\n/**\n * Update profile data on Firebase Real Time Database\n * @param {object} firebase - internal firebase object\n * @param {object} profileUpdate - Updates to profile object\n * @returns {Promise} Resolves with results of profile get\n */\nexport function updateProfileOnRTDB(firebase, profileUpdate) {\n  const {\n    _: { config, authUid }\n  } = firebase\n  const profileRef = firebase.database().ref(`${config.userProfile}/${authUid}`)\n  return profileRef.update(profileUpdate).then(() => profileRef.once('value'))\n}\n\n/**\n * Update profile data on Firestore by calling set (with merge: true) on\n * the profile.\n * @param {object} firebase - internal firebase object\n * @param {object} profileUpdate - Updates to profile object\n * @param {object} options - Options object for configuring how profile\n * update occurs\n * @param {boolean} [options.useSet=true] - Use set with merge instead of\n * update. Setting to `false` uses update (can cause issue if profile document\n * does not exist).\n * @param {boolean} [options.merge=true] - Whether or not to use merge when\n * setting profile\n * @returns {Promise} Resolves with results of profile get\n */\nexport function updateProfileOnFirestore(\n  firebase,\n  profileUpdate,\n  options = {}\n) {\n  const { useSet = true, merge = true } = options\n  const {\n    firestore,\n    _: { config, authUid }\n  } = firebase\n  const profileRef = firestore().doc(`${config.userProfile}/${authUid}`)\n  // Use set with merge (to prevent \"No document to update\") unless otherwise\n  // specificed through options\n  const profileUpdatePromise = useSet\n    ? profileRef.set(profileUpdate, { merge })\n    : profileRef.update(profileUpdate)\n  return profileUpdatePromise.then(() => profileRef.get())\n}\n\n/**\n * Start presence management for a specificed user uid.\n * Presence collection contains a list of users that are online currently.\n * Sessions collection contains a record of all user sessions.\n * This function is called within login functions if enablePresence: true.\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @private\n */\nexport function setupPresence(dispatch, firebase) {\n  // exit if database does not exist on firebase instance\n  if (!firebase.database || !firebase.database.ServerValue) {\n    return\n  }\n  const ref = firebase.database().ref()\n  const {\n    config: { presence, sessions },\n    authUid\n  } = firebase._\n  const amOnline = ref.child('.info/connected')\n  const onlineRef = ref\n    .child(\n      typeof presence === 'function'\n        ? presence(firebase.auth().currentUser, firebase)\n        : presence\n    )\n    .child(authUid)\n  let sessionsRef =\n    typeof sessions === 'function'\n      ? sessions(firebase.auth().currentUser, firebase)\n      : sessions\n  if (sessionsRef) {\n    sessionsRef = ref.child(sessions)\n  }\n  amOnline.on('value', (snapShot) => {\n    if (!snapShot.val()) return\n    // user is online\n    if (sessionsRef) {\n      // add session and set disconnect\n      dispatch({ type: actionTypes.SESSION_START, payload: authUid })\n      // add new session to sessions collection\n      const session = sessionsRef.push({\n        startedAt: firebase.database.ServerValue.TIMESTAMP,\n        user: authUid\n      })\n      // Support versions of react-native-firebase that do not have setPriority\n      // on firebase.database.ThenableReference\n      if (typeof session.setPriority === 'function') {\n        // set authUid as priority for easy sorting\n        session.setPriority(authUid)\n      }\n      session\n        .child('endedAt')\n        .onDisconnect()\n        .set(firebase.database.ServerValue.TIMESTAMP, () => {\n          dispatch({ type: actionTypes.SESSION_END })\n        })\n    }\n    // add correct session id to user\n    // remove from presence list\n    onlineRef.set(true)\n    onlineRef.onDisconnect().remove()\n  })\n}\n"]},"metadata":{},"sourceType":"script"}