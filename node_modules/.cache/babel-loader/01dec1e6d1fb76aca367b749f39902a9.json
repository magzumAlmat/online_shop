{"ast":null,"code":"import { checkRequired, createValidator, createValidatorAsync, isEmpty, formatErrorMessage } from './utils';\nimport locales from './locales';\nexport class MixedType {\n  constructor(name) {\n    this.required = false;\n    this.requiredMessage = '';\n    this.trim = false;\n    this.emptyAllowed = false;\n    this.rules = [];\n    this.priorityRules = [];\n    this.typeName = name;\n    this.locale = Object.assign(name ? locales[name] : {}, locales.mixed);\n  }\n\n  setSchemaOptions(schemaSpec, value) {\n    this.schemaSpec = schemaSpec;\n    this.value = value;\n  }\n\n  check() {\n    let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.value;\n    let data = arguments.length > 1 ? arguments[1] : undefined;\n    let fieldName = arguments.length > 2 ? arguments[2] : undefined;\n\n    if (this.required && !checkRequired(value, this.trim, this.emptyAllowed)) {\n      return {\n        hasError: true,\n        errorMessage: formatErrorMessage(this.requiredMessage, {\n          name: fieldName\n        })\n      };\n    }\n\n    const validator = createValidator(data, fieldName);\n    const checkStatus = validator(value, this.priorityRules);\n\n    if (checkStatus) {\n      return checkStatus;\n    }\n\n    if (!this.required && isEmpty(value)) {\n      return {\n        hasError: false\n      };\n    }\n\n    return validator(value, this.rules) || {\n      hasError: false\n    };\n  }\n\n  checkAsync() {\n    let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.value;\n    let data = arguments.length > 1 ? arguments[1] : undefined;\n    let fieldName = arguments.length > 2 ? arguments[2] : undefined;\n\n    if (this.required && !checkRequired(value, this.trim, this.emptyAllowed)) {\n      return Promise.resolve({\n        hasError: true,\n        errorMessage: formatErrorMessage(this.requiredMessage, {\n          name: fieldName\n        })\n      });\n    }\n\n    const validator = createValidatorAsync(data, fieldName);\n    return new Promise(resolve => validator(value, this.priorityRules).then(checkStatus => {\n      if (checkStatus) {\n        resolve(checkStatus);\n      }\n    }).then(() => {\n      if (!this.required && isEmpty(value)) {\n        resolve({\n          hasError: false\n        });\n      }\n    }).then(() => validator(value, this.rules)).then(checkStatus => {\n      if (checkStatus) {\n        resolve(checkStatus);\n      }\n\n      resolve({\n        hasError: false\n      });\n    }));\n  }\n\n  pushRule(rule) {\n    var _a, _b;\n\n    const {\n      onValid,\n      errorMessage,\n      priority,\n      params\n    } = rule;\n    const nextRule = {\n      onValid,\n      params,\n      isAsync: rule.isAsync,\n      errorMessage: errorMessage || ((_b = (_a = this.rules) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.errorMessage)\n    };\n\n    if (priority) {\n      this.priorityRules.push(nextRule);\n    } else {\n      this.rules.push(nextRule);\n    }\n  }\n\n  addRule(onValid, errorMessage, priority) {\n    this.pushRule({\n      onValid,\n      errorMessage,\n      priority\n    });\n    return this;\n  }\n\n  addAsyncRule(onValid, errorMessage, priority) {\n    this.pushRule({\n      onValid,\n      isAsync: true,\n      errorMessage,\n      priority\n    });\n    return this;\n  }\n\n  isRequired() {\n    let errorMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.locale.isRequired;\n    let trim = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.required = true;\n    this.trim = trim;\n    this.requiredMessage = errorMessage;\n    return this;\n  }\n\n  isRequiredOrEmpty() {\n    let errorMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.locale.isRequiredOrEmpty;\n    let trim = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.required = true;\n    this.trim = trim;\n    this.emptyAllowed = true;\n    this.requiredMessage = errorMessage;\n    return this;\n  }\n  /**\n   * Define data verification rules based on conditions.\n   * @param validator\n   * @example\n   * MixedType().when(schema => {\n   *   return schema.filed1.check() ? NumberType().min(5) : NumberType().min(0);\n   * });\n   */\n\n\n  when(condition) {\n    this.addRule((value, data, filedName) => {\n      return condition(this.schemaSpec).check(value, data, filedName);\n    }, undefined, true);\n    return this;\n  }\n\n}\nexport default function getMixedType() {\n  return new MixedType();\n}","map":{"version":3,"sources":["../src/MixedType.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { checkRequired, createValidator, createValidatorAsync, isEmpty, formatErrorMessage } from './utils';\nimport locales from './locales';\nexport class MixedType {\n    constructor(name) {\n        this.required = false;\n        this.requiredMessage = '';\n        this.trim = false;\n        this.emptyAllowed = false;\n        this.rules = [];\n        this.priorityRules = [];\n        this.typeName = name;\n        this.locale = Object.assign(name ? locales[name] : {}, locales.mixed);\n    }\n    setSchemaOptions(schemaSpec, value) {\n        this.schemaSpec = schemaSpec;\n        this.value = value;\n    }\n    check(value = this.value, data, fieldName) {\n        if (this.required && !checkRequired(value, this.trim, this.emptyAllowed)) {\n            return {\n                hasError: true,\n                errorMessage: formatErrorMessage(this.requiredMessage, { name: fieldName })\n            };\n        }\n        const validator = createValidator(data, fieldName);\n        const checkStatus = validator(value, this.priorityRules);\n        if (checkStatus) {\n            return checkStatus;\n        }\n        if (!this.required && isEmpty(value)) {\n            return { hasError: false };\n        }\n        return validator(value, this.rules) || { hasError: false };\n    }\n    checkAsync(value = this.value, data, fieldName) {\n        if (this.required && !checkRequired(value, this.trim, this.emptyAllowed)) {\n            return Promise.resolve({\n                hasError: true,\n                errorMessage: formatErrorMessage(this.requiredMessage, { name: fieldName })\n            });\n        }\n        const validator = createValidatorAsync(data, fieldName);\n        return new Promise(resolve => validator(value, this.priorityRules)\n            .then((checkStatus) => {\n            if (checkStatus) {\n                resolve(checkStatus);\n            }\n        })\n            .then(() => {\n            if (!this.required && isEmpty(value)) {\n                resolve({ hasError: false });\n            }\n        })\n            .then(() => validator(value, this.rules))\n            .then((checkStatus) => {\n            if (checkStatus) {\n                resolve(checkStatus);\n            }\n            resolve({ hasError: false });\n        }));\n    }\n    pushRule(rule) {\n        var _a, _b;\n        const { onValid, errorMessage, priority, params } = rule;\n        const nextRule = {\n            onValid,\n            params,\n            isAsync: rule.isAsync,\n            errorMessage: errorMessage || ((_b = (_a = this.rules) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.errorMessage)\n        };\n        if (priority) {\n            this.priorityRules.push(nextRule);\n        }\n        else {\n            this.rules.push(nextRule);\n        }\n    }\n    addRule(onValid, errorMessage, priority) {\n        this.pushRule({ onValid, errorMessage, priority });\n        return this;\n    }\n    addAsyncRule(onValid, errorMessage, priority) {\n        this.pushRule({ onValid, isAsync: true, errorMessage, priority });\n        return this;\n    }\n    isRequired(errorMessage = this.locale.isRequired, trim = true) {\n        this.required = true;\n        this.trim = trim;\n        this.requiredMessage = errorMessage;\n        return this;\n    }\n    isRequiredOrEmpty(errorMessage = this.locale.isRequiredOrEmpty, trim = true) {\n        this.required = true;\n        this.trim = trim;\n        this.emptyAllowed = true;\n        this.requiredMessage = errorMessage;\n        return this;\n    }\n    /**\n     * Define data verification rules based on conditions.\n     * @param validator\n     * @example\n     * MixedType().when(schema => {\n     *   return schema.filed1.check() ? NumberType().min(5) : NumberType().min(0);\n     * });\n     */\n    when(condition) {\n        this.addRule((value, data, filedName) => {\n            return condition(this.schemaSpec).check(value, data, filedName);\n        }, undefined, true);\n        return this;\n    }\n}\nexport default function getMixedType() {\n    return new MixedType();\n}\n//# sourceMappingURL=MixedType.js.map"]},"metadata":{},"sourceType":"module"}