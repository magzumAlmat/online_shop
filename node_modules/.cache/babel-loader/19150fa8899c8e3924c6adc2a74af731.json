{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.uploadFile = uploadFile, exports.uploadFiles = uploadFiles, exports.deleteFile = deleteFile;\n\nvar _map2 = _interopRequireDefault(require(\"lodash/map\")),\n    _constants = require(\"../constants\"),\n    _actions = require(\"../utils/actions\"),\n    _storage = require(\"../utils/storage\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (null == source) return {};\n\n  var key,\n      i,\n      target = _objectWithoutPropertiesLoose(source, excluded);\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) key = sourceSymbolKeys[i], 0 <= excluded.indexOf(key) || Object.prototype.propertyIsEnumerable.call(source, key) && (target[key] = source[key]);\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (null == source) return {};\n  var key,\n      i,\n      target = {},\n      sourceKeys = Object.keys(source);\n\n  for (i = 0; i < sourceKeys.length; i++) key = sourceKeys[i], 0 <= excluded.indexOf(key) || (target[key] = source[key]);\n\n  return target;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var source, i = 1; i < arguments.length; i++) source = null == arguments[i] ? {} : arguments[i], i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n    _defineProperty(target, key, source[key]);\n  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n  });\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  return key in obj ? Object.defineProperty(obj, key, {\n    value: value,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : obj[key] = value, obj;\n}\n\nvar FILE_UPLOAD_START = _constants.actionTypes.FILE_UPLOAD_START,\n    FILE_UPLOAD_ERROR = _constants.actionTypes.FILE_UPLOAD_ERROR,\n    FILE_UPLOAD_COMPLETE = _constants.actionTypes.FILE_UPLOAD_COMPLETE,\n    FILE_DELETE_START = _constants.actionTypes.FILE_DELETE_START,\n    FILE_DELETE_ERROR = _constants.actionTypes.FILE_DELETE_ERROR,\n    FILE_DELETE_COMPLETE = _constants.actionTypes.FILE_DELETE_COMPLETE;\n\nfunction uploadFile(dispatch, firebase, config) {\n  if (!firebase.storage) throw new Error(\"Firebase storage is required to upload files\");\n\n  var _ref = config || {},\n      path = _ref.path,\n      file = _ref.file,\n      dbPath = _ref.dbPath,\n      _ref$options = _ref.options,\n      options = void 0 === _ref$options ? {\n    progress: !1\n  } : _ref$options,\n      fileMetadata = (options || {}).metadata,\n      logErrors = firebase._.config.logErrors,\n      nameFromOptions = \"function\" == typeof options.name ? options.name(file, firebase, config) : options.name,\n      filename = nameFromOptions || file.name,\n      meta = _objectSpread(_objectSpread({}, config), {}, {\n    filename: filename\n  });\n\n  dispatch({\n    type: FILE_UPLOAD_START,\n    payload: _objectSpread(_objectSpread({}, config), {}, {\n      filename: filename\n    })\n  });\n  return function uploadPromise() {\n    return options.progress ? (0, _storage.uploadFileWithProgress)(dispatch, firebase, {\n      path: path,\n      file: file,\n      filename: filename,\n      meta: meta,\n      fileMetadata: fileMetadata\n    }) : firebase.storage().ref(\"\".concat(path, \"/\").concat(filename)).put(file, fileMetadata);\n  }().then(function (uploadTaskSnapshot) {\n    return dbPath && (firebase.database || firebase.firestore) ? (0, _storage.writeMetadataToDb)({\n      firebase: firebase,\n      uploadTaskSnapshot: uploadTaskSnapshot,\n      dbPath: dbPath,\n      options: options\n    }).then(function (payload) {\n      return dispatch({\n        type: FILE_UPLOAD_COMPLETE,\n        meta: _objectSpread(_objectSpread({}, config), {}, {\n          filename: filename\n        }),\n        payload: payload\n      }), payload;\n    }) : (dispatch({\n      type: FILE_UPLOAD_COMPLETE,\n      meta: _objectSpread(_objectSpread({}, config), {}, {\n        filename: filename\n      }),\n      payload: {\n        uploadTaskSnapshot: uploadTaskSnapshot,\n        uploadTaskSnaphot: uploadTaskSnapshot\n      }\n    }), {\n      uploadTaskSnapshot: uploadTaskSnapshot,\n      uploadTaskSnaphot: uploadTaskSnapshot\n    });\n  }).catch(function (err) {\n    return logErrors && console.error && console.error(\"RRF: Error uploading file: \".concat(err.message || err), err), dispatch({\n      type: FILE_UPLOAD_ERROR,\n      path: path,\n      payload: err\n    }), Promise.reject(err);\n  });\n}\n\nfunction uploadFiles(dispatch, firebase, _ref3) {\n  var files = _ref3.files,\n      other = _objectWithoutProperties(_ref3, [\"files\"]);\n\n  return Promise.all((0, _map2.default)(files, function (file) {\n    return uploadFile(dispatch, firebase, _objectSpread({\n      file: file\n    }, other));\n  }));\n}\n\nfunction deleteFile(dispatch, firebase, _ref4) {\n  var path = _ref4.path,\n      dbPath = _ref4.dbPath;\n  return (0, _actions.wrapInDispatch)(dispatch, {\n    method: _storage.deleteFile,\n    args: [firebase, {\n      path: path,\n      dbPath: dbPath\n    }],\n    types: [FILE_DELETE_START, FILE_DELETE_COMPLETE, FILE_DELETE_ERROR]\n  });\n}","map":{"version":3,"sources":["../../src/actions/storage.js"],"names":["FILE_UPLOAD_START","FILE_UPLOAD_ERROR","FILE_UPLOAD_COMPLETE","FILE_DELETE_START","FILE_DELETE_ERROR","FILE_DELETE_COMPLETE","actionTypes","firebase","path","file","dbPath","options","progress","config","fileMetadata","logErrors","nameFromOptions","filename","meta","dispatch","type","payload","uploadPromise","uploadTaskSnapshot","uploadTaskSnaphot","console","err","Promise","files","other","uploadFile","method","deleteFileFromFb","args","types"],"mappings":"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","sourcesContent":["import { map } from 'lodash'\nimport { actionTypes } from '../constants'\nimport { wrapInDispatch } from '../utils/actions'\nimport {\n  deleteFile as deleteFileFromFb,\n  writeMetadataToDb,\n  uploadFileWithProgress\n} from '../utils/storage'\n\nconst {\n  FILE_UPLOAD_START,\n  FILE_UPLOAD_ERROR,\n  FILE_UPLOAD_COMPLETE,\n  FILE_DELETE_START,\n  FILE_DELETE_ERROR,\n  FILE_DELETE_COMPLETE\n} = actionTypes\n\n/**\n * Upload file to Firebase Storage with option to store\n * file metadata within Firebase Database\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} config - Config object\n * @param {string} config.path - Location within Firebase Stroage at which to upload files.\n * @param {Blob} config.file - File Blob to be uploaded\n * @param {string} config.dbPath - Datbase path to write file meta data to\n * @param {object} config.options - Options\n * @param {string|Function} config.options.name - Name of file. If a function\n * is provided it recieves (fileObject, internalFirebase, config) as arguments.\n * @param {object} config.options.metdata - Metadata for file to be passed along\n * to storage.put calls\n * @param {object} config.options.documentId - Id of document to update with metadata if using Firestore\n * @returns {Promise} Resolves with meta object\n * @private\n */\nexport function uploadFile(dispatch, firebase, config) {\n  if (!firebase.storage) {\n    throw new Error('Firebase storage is required to upload files')\n  }\n  const { path, file, dbPath, options = { progress: false } } = config || {}\n  const { metadata: fileMetadata } = options || {}\n  const { logErrors } = firebase._.config\n\n  // File renaming through options (supporting string and function)\n  const nameFromOptions =\n    typeof options.name === 'function'\n      ? options.name(file, firebase, config)\n      : options.name\n  const filename = nameFromOptions || file.name\n\n  const meta = { ...config, filename }\n\n  // Dispatch start action\n  dispatch({ type: FILE_UPLOAD_START, payload: { ...config, filename } })\n\n  const uploadPromise = () =>\n    options.progress\n      ? uploadFileWithProgress(dispatch, firebase, {\n          path,\n          file,\n          filename,\n          meta,\n          fileMetadata\n        })\n      : firebase.storage().ref(`${path}/${filename}`).put(file, fileMetadata)\n\n  return uploadPromise()\n    .then((uploadTaskSnapshot) => {\n      if (!dbPath || (!firebase.database && !firebase.firestore)) {\n        dispatch({\n          type: FILE_UPLOAD_COMPLETE,\n          meta: { ...config, filename },\n          payload: {\n            uploadTaskSnapshot,\n            uploadTaskSnaphot: uploadTaskSnapshot // Preserving legacy typo\n          }\n        })\n        return {\n          uploadTaskSnapshot,\n          uploadTaskSnaphot: uploadTaskSnapshot // Preserving legacy typo\n        }\n      }\n\n      // Write File metadata to either Real Time Database or Firestore (depending on config)\n      return writeMetadataToDb({\n        firebase,\n        uploadTaskSnapshot,\n        dbPath,\n        options\n      }).then((payload) => {\n        dispatch({\n          type: FILE_UPLOAD_COMPLETE,\n          meta: { ...config, filename },\n          payload\n        })\n        return payload\n      })\n    })\n    .catch((err) => {\n      if (logErrors) {\n        /* eslint-disable no-console */\n        console.error &&\n          console.error(`RRF: Error uploading file: ${err.message || err}`, err)\n        /* eslint-enable no-console */\n      }\n      dispatch({ type: FILE_UPLOAD_ERROR, path, payload: err })\n      return Promise.reject(err)\n    })\n}\n\n/**\n * Upload multiple files to Firebase Storage with option to store\n * file's metadata within Firebase Database\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} opts - Options object\n * @param {string} opts.path - Storage path to write files to\n * @param {Array} opts.files - List of files to be uploaded\n * @param {string} opts.dbPath - Datbase path to write file meta data to\n * @returns {Promise} Resolves with array of meta objects\n * @private\n */\nexport function uploadFiles(dispatch, firebase, { files, ...other }) {\n  return Promise.all(\n    map(files, (file) => uploadFile(dispatch, firebase, { file, ...other }))\n  )\n}\n\n/**\n * Delete File from Firebase Storage with option to remove meta\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} opts - Options object\n * @param {string} opts.path - Storage path to write files to\n * @param {string} opts.dbPath - Datbase path to write file meta data to\n * @returns {Promise} Resolves with results of deleting a file from storage\n * @private\n */\nexport function deleteFile(dispatch, firebase, { path, dbPath }) {\n  return wrapInDispatch(dispatch, {\n    method: deleteFileFromFb,\n    args: [firebase, { path, dbPath }],\n    types: [FILE_DELETE_START, FILE_DELETE_COMPLETE, FILE_DELETE_ERROR]\n  })\n}\n"]},"metadata":{},"sourceType":"script"}