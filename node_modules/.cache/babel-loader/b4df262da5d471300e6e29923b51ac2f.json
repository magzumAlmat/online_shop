{"ast":null,"code":"import { MixedType } from './MixedType';\nimport { createValidator, createValidatorAsync, checkRequired, isEmpty } from './utils';\nexport class ObjectType extends MixedType {\n  constructor(errorMessage) {\n    super('object');\n    super.pushRule({\n      onValid: v => typeof v === 'object',\n      errorMessage: errorMessage || this.locale.type\n    });\n  }\n\n  check() {\n    let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.value;\n    let data = arguments.length > 1 ? arguments[1] : undefined;\n    let fieldName = arguments.length > 2 ? arguments[2] : undefined;\n\n    const check = (value, data, type) => {\n      if (type.required && !checkRequired(value, type.trim, type.emptyAllowed)) {\n        return {\n          hasError: true,\n          errorMessage: type.requiredMessage\n        };\n      }\n\n      if (type.objectTypeSchemaSpec && typeof value === 'object') {\n        const checkResultObject = {};\n        let hasError = false;\n        Object.entries(type.objectTypeSchemaSpec).forEach(_ref => {\n          let [k, v] = _ref;\n          const checkResult = check(value[k], value, v);\n\n          if (checkResult === null || checkResult === void 0 ? void 0 : checkResult.hasError) {\n            hasError = true;\n          }\n\n          checkResultObject[k] = checkResult;\n        });\n        return {\n          hasError,\n          object: checkResultObject\n        };\n      }\n\n      const validator = createValidator(data, fieldName);\n      const checkStatus = validator(value, type.priorityRules);\n\n      if (checkStatus) {\n        return checkStatus;\n      }\n\n      if (!type.required && isEmpty(value)) {\n        return {\n          hasError: false\n        };\n      }\n\n      return validator(value, type.rules) || {\n        hasError: false\n      };\n    };\n\n    return check(value, data, this);\n  }\n\n  checkAsync() {\n    let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.value;\n    let data = arguments.length > 1 ? arguments[1] : undefined;\n    let fieldName = arguments.length > 2 ? arguments[2] : undefined;\n\n    const check = (value, data, type) => {\n      if (type.required && !checkRequired(value, type.trim, type.emptyAllowed)) {\n        return Promise.resolve({\n          hasError: true,\n          errorMessage: this.requiredMessage\n        });\n      }\n\n      const validator = createValidatorAsync(data, fieldName);\n      return new Promise(resolve => {\n        if (type.objectTypeSchemaSpec && typeof value === 'object') {\n          const checkResult = {};\n          const checkAll = [];\n          const keys = [];\n          Object.entries(type.objectTypeSchemaSpec).forEach(_ref2 => {\n            let [k, v] = _ref2;\n            checkAll.push(check(value[k], value, v));\n            keys.push(k);\n          });\n          return Promise.all(checkAll).then(values => {\n            values.forEach((v, index) => {\n              checkResult[keys[index]] = v;\n            });\n            resolve({\n              object: checkResult\n            });\n          });\n        }\n\n        return validator(value, type.priorityRules).then(checkStatus => {\n          if (checkStatus) {\n            resolve(checkStatus);\n          }\n        }).then(() => {\n          if (!type.required && isEmpty(value)) {\n            resolve({\n              hasError: false\n            });\n          }\n        }).then(() => validator(value, type.rules)).then(checkStatus => {\n          if (checkStatus) {\n            resolve(checkStatus);\n          }\n\n          resolve({\n            hasError: false\n          });\n        });\n      });\n    };\n\n    return check(value, data, this);\n  }\n  /**\n   * @example\n   * ObjectType().shape({\n   *  name: StringType(),\n   *  age: NumberType()\n   * })\n   */\n\n\n  shape(fields) {\n    this.objectTypeSchemaSpec = fields;\n    return this;\n  }\n\n}\nexport default function getObjectType(errorMessage) {\n  return new ObjectType(errorMessage);\n}","map":{"version":3,"sources":["../src/ObjectType.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { MixedType } from './MixedType';\nimport { createValidator, createValidatorAsync, checkRequired, isEmpty } from './utils';\nexport class ObjectType extends MixedType {\n    constructor(errorMessage) {\n        super('object');\n        super.pushRule({\n            onValid: v => typeof v === 'object',\n            errorMessage: errorMessage || this.locale.type\n        });\n    }\n    check(value = this.value, data, fieldName) {\n        const check = (value, data, type) => {\n            if (type.required && !checkRequired(value, type.trim, type.emptyAllowed)) {\n                return { hasError: true, errorMessage: type.requiredMessage };\n            }\n            if (type.objectTypeSchemaSpec && typeof value === 'object') {\n                const checkResultObject = {};\n                let hasError = false;\n                Object.entries(type.objectTypeSchemaSpec).forEach(([k, v]) => {\n                    const checkResult = check(value[k], value, v);\n                    if (checkResult === null || checkResult === void 0 ? void 0 : checkResult.hasError) {\n                        hasError = true;\n                    }\n                    checkResultObject[k] = checkResult;\n                });\n                return { hasError, object: checkResultObject };\n            }\n            const validator = createValidator(data, fieldName);\n            const checkStatus = validator(value, type.priorityRules);\n            if (checkStatus) {\n                return checkStatus;\n            }\n            if (!type.required && isEmpty(value)) {\n                return { hasError: false };\n            }\n            return validator(value, type.rules) || { hasError: false };\n        };\n        return check(value, data, this);\n    }\n    checkAsync(value = this.value, data, fieldName) {\n        const check = (value, data, type) => {\n            if (type.required && !checkRequired(value, type.trim, type.emptyAllowed)) {\n                return Promise.resolve({ hasError: true, errorMessage: this.requiredMessage });\n            }\n            const validator = createValidatorAsync(data, fieldName);\n            return new Promise(resolve => {\n                if (type.objectTypeSchemaSpec && typeof value === 'object') {\n                    const checkResult = {};\n                    const checkAll = [];\n                    const keys = [];\n                    Object.entries(type.objectTypeSchemaSpec).forEach(([k, v]) => {\n                        checkAll.push(check(value[k], value, v));\n                        keys.push(k);\n                    });\n                    return Promise.all(checkAll).then(values => {\n                        values.forEach((v, index) => {\n                            checkResult[keys[index]] = v;\n                        });\n                        resolve({ object: checkResult });\n                    });\n                }\n                return validator(value, type.priorityRules)\n                    .then((checkStatus) => {\n                    if (checkStatus) {\n                        resolve(checkStatus);\n                    }\n                })\n                    .then(() => {\n                    if (!type.required && isEmpty(value)) {\n                        resolve({ hasError: false });\n                    }\n                })\n                    .then(() => validator(value, type.rules))\n                    .then((checkStatus) => {\n                    if (checkStatus) {\n                        resolve(checkStatus);\n                    }\n                    resolve({ hasError: false });\n                });\n            });\n        };\n        return check(value, data, this);\n    }\n    /**\n     * @example\n     * ObjectType().shape({\n     *  name: StringType(),\n     *  age: NumberType()\n     * })\n     */\n    shape(fields) {\n        this.objectTypeSchemaSpec = fields;\n        return this;\n    }\n}\nexport default function getObjectType(errorMessage) {\n    return new ObjectType(errorMessage);\n}\n//# sourceMappingURL=ObjectType.js.map"]},"metadata":{},"sourceType":"module"}