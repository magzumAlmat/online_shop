{"ast":null,"code":"import { createRule } from 'jss';\nvar now = Date.now();\nvar fnValuesNs = \"fnValues\" + now;\nvar fnRuleNs = \"fnStyle\" + ++now;\n\nfunction functionPlugin() {\n  return {\n    onCreateRule: function onCreateRule(name, decl, options) {\n      if (typeof decl !== 'function') return null;\n      var rule = createRule(name, {}, options);\n      rule[fnRuleNs] = decl;\n      return rule;\n    },\n    onProcessStyle: function onProcessStyle(style, rule) {\n      // We need to extract function values from the declaration, so that we can keep core unaware of them.\n      // We need to do that only once.\n      // We don't need to extract functions on each style update, since this can happen only once.\n      // We don't support function values inside of function rules.\n      if (fnValuesNs in rule || fnRuleNs in rule) return style;\n      var fnValues = {};\n\n      for (var prop in style) {\n        var value = style[prop];\n        if (typeof value !== 'function') continue;\n        delete style[prop];\n        fnValues[prop] = value;\n      } // $FlowFixMe\n\n\n      rule[fnValuesNs] = fnValues;\n      return style;\n    },\n    onUpdate: function onUpdate(data, rule, sheet, options) {\n      var styleRule = rule;\n      var fnRule = styleRule[fnRuleNs]; // If we have a style function, the entire rule is dynamic and style object\n      // will be returned from that function.\n\n      if (fnRule) {\n        styleRule.style = fnRule(data);\n      }\n\n      var fnValues = styleRule[fnValuesNs]; // If we have a fn values map, it is a rule with function values.\n\n      if (fnValues) {\n        for (var prop in fnValues) {\n          styleRule.prop(prop, fnValues[prop](data), options);\n        }\n      }\n    }\n  };\n}\n\nexport default functionPlugin;","map":{"version":3,"names":["createRule","now","Date","fnValuesNs","fnRuleNs","functionPlugin","onCreateRule","name","decl","options","rule","onProcessStyle","style","fnValues","prop","value","onUpdate","data","sheet","styleRule","fnRule"],"sources":["/Users/billionare/Documents/reactSmartshop/SmartShopProduction-main/node_modules/jss-plugin-rule-value-function/dist/jss-plugin-rule-value-function.esm.js"],"sourcesContent":["import { createRule } from 'jss';\n\nvar now = Date.now();\nvar fnValuesNs = \"fnValues\" + now;\nvar fnRuleNs = \"fnStyle\" + ++now;\nfunction functionPlugin() {\n  return {\n    onCreateRule: function onCreateRule(name, decl, options) {\n      if (typeof decl !== 'function') return null;\n      var rule = createRule(name, {}, options);\n      rule[fnRuleNs] = decl;\n      return rule;\n    },\n    onProcessStyle: function onProcessStyle(style, rule) {\n      // We need to extract function values from the declaration, so that we can keep core unaware of them.\n      // We need to do that only once.\n      // We don't need to extract functions on each style update, since this can happen only once.\n      // We don't support function values inside of function rules.\n      if (fnValuesNs in rule || fnRuleNs in rule) return style;\n      var fnValues = {};\n\n      for (var prop in style) {\n        var value = style[prop];\n        if (typeof value !== 'function') continue;\n        delete style[prop];\n        fnValues[prop] = value;\n      } // $FlowFixMe\n\n\n      rule[fnValuesNs] = fnValues;\n      return style;\n    },\n    onUpdate: function onUpdate(data, rule, sheet, options) {\n      var styleRule = rule;\n      var fnRule = styleRule[fnRuleNs]; // If we have a style function, the entire rule is dynamic and style object\n      // will be returned from that function.\n\n      if (fnRule) {\n        styleRule.style = fnRule(data);\n      }\n\n      var fnValues = styleRule[fnValuesNs]; // If we have a fn values map, it is a rule with function values.\n\n      if (fnValues) {\n        for (var prop in fnValues) {\n          styleRule.prop(prop, fnValues[prop](data), options);\n        }\n      }\n    }\n  };\n}\n\nexport default functionPlugin;\n"],"mappings":"AAAA,SAASA,UAAT,QAA2B,KAA3B;AAEA,IAAIC,GAAG,GAAGC,IAAI,CAACD,GAAL,EAAV;AACA,IAAIE,UAAU,GAAG,aAAaF,GAA9B;AACA,IAAIG,QAAQ,GAAG,YAAY,EAAEH,GAA7B;;AACA,SAASI,cAAT,GAA0B;EACxB,OAAO;IACLC,YAAY,EAAE,SAASA,YAAT,CAAsBC,IAAtB,EAA4BC,IAA5B,EAAkCC,OAAlC,EAA2C;MACvD,IAAI,OAAOD,IAAP,KAAgB,UAApB,EAAgC,OAAO,IAAP;MAChC,IAAIE,IAAI,GAAGV,UAAU,CAACO,IAAD,EAAO,EAAP,EAAWE,OAAX,CAArB;MACAC,IAAI,CAACN,QAAD,CAAJ,GAAiBI,IAAjB;MACA,OAAOE,IAAP;IACD,CANI;IAOLC,cAAc,EAAE,SAASA,cAAT,CAAwBC,KAAxB,EAA+BF,IAA/B,EAAqC;MACnD;MACA;MACA;MACA;MACA,IAAIP,UAAU,IAAIO,IAAd,IAAsBN,QAAQ,IAAIM,IAAtC,EAA4C,OAAOE,KAAP;MAC5C,IAAIC,QAAQ,GAAG,EAAf;;MAEA,KAAK,IAAIC,IAAT,IAAiBF,KAAjB,EAAwB;QACtB,IAAIG,KAAK,GAAGH,KAAK,CAACE,IAAD,CAAjB;QACA,IAAI,OAAOC,KAAP,KAAiB,UAArB,EAAiC;QACjC,OAAOH,KAAK,CAACE,IAAD,CAAZ;QACAD,QAAQ,CAACC,IAAD,CAAR,GAAiBC,KAAjB;MACD,CAbkD,CAajD;;;MAGFL,IAAI,CAACP,UAAD,CAAJ,GAAmBU,QAAnB;MACA,OAAOD,KAAP;IACD,CAzBI;IA0BLI,QAAQ,EAAE,SAASA,QAAT,CAAkBC,IAAlB,EAAwBP,IAAxB,EAA8BQ,KAA9B,EAAqCT,OAArC,EAA8C;MACtD,IAAIU,SAAS,GAAGT,IAAhB;MACA,IAAIU,MAAM,GAAGD,SAAS,CAACf,QAAD,CAAtB,CAFsD,CAEpB;MAClC;;MAEA,IAAIgB,MAAJ,EAAY;QACVD,SAAS,CAACP,KAAV,GAAkBQ,MAAM,CAACH,IAAD,CAAxB;MACD;;MAED,IAAIJ,QAAQ,GAAGM,SAAS,CAAChB,UAAD,CAAxB,CATsD,CAShB;;MAEtC,IAAIU,QAAJ,EAAc;QACZ,KAAK,IAAIC,IAAT,IAAiBD,QAAjB,EAA2B;UACzBM,SAAS,CAACL,IAAV,CAAeA,IAAf,EAAqBD,QAAQ,CAACC,IAAD,CAAR,CAAeG,IAAf,CAArB,EAA2CR,OAA3C;QACD;MACF;IACF;EA1CI,CAAP;AA4CD;;AAED,eAAeJ,cAAf"},"metadata":{},"sourceType":"module"}