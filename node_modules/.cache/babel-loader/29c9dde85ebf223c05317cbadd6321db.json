{"ast":null,"code":"export class Schema {\n  constructor(schema) {\n    this.spec = schema;\n  }\n\n  getFieldType(fieldName) {\n    var _a;\n\n    return (_a = this.spec) === null || _a === void 0 ? void 0 : _a[fieldName];\n  }\n\n  getKeys() {\n    return Object.keys(this.spec);\n  }\n\n  setSchemaOptionsForAllType(data) {\n    if (data === this.data) {\n      return;\n    }\n\n    Object.entries(this.spec).forEach(_ref => {\n      let [key, type] = _ref;\n      type.setSchemaOptions(this.spec, data === null || data === void 0 ? void 0 : data[key]);\n    });\n    this.data = data;\n  }\n\n  checkForField(fieldName, data) {\n    this.setSchemaOptionsForAllType(data);\n    const fieldChecker = this.spec[fieldName];\n\n    if (!fieldChecker) {\n      // fieldValue can be anything if no schema defined\n      return {\n        hasError: false\n      };\n    }\n\n    return fieldChecker.check(data[fieldName], data, fieldName);\n  }\n\n  checkForFieldAsync(fieldName, data) {\n    this.setSchemaOptionsForAllType(data);\n    const fieldChecker = this.spec[fieldName];\n\n    if (!fieldChecker) {\n      // fieldValue can be anything if no schema defined\n      return Promise.resolve({\n        hasError: false\n      });\n    }\n\n    return fieldChecker.checkAsync(data[fieldName], data, fieldName);\n  }\n\n  check(data) {\n    const checkResult = {};\n    Object.keys(this.spec).forEach(key => {\n      if (typeof data === 'object') {\n        checkResult[key] = this.checkForField(key, data);\n      }\n    });\n    return checkResult;\n  }\n\n  checkAsync(data) {\n    const checkResult = {};\n    const promises = [];\n    const keys = [];\n    Object.keys(this.spec).forEach(key => {\n      keys.push(key);\n      promises.push(this.checkForFieldAsync(key, data));\n    });\n    return Promise.all(promises).then(values => {\n      for (let i = 0; i < values.length; i += 1) {\n        checkResult[keys[i]] = values[i];\n      }\n\n      return checkResult;\n    });\n  }\n\n}\nexport function SchemaModel(o) {\n  return new Schema(o);\n}\n\nSchemaModel.combine = function combine() {\n  for (var _len = arguments.length, specs = new Array(_len), _key = 0; _key < _len; _key++) {\n    specs[_key] = arguments[_key];\n  }\n\n  return new Schema(specs.map(model => model.spec).reduce((accumulator, currentValue) => Object.assign(accumulator, currentValue), {}));\n};","map":{"version":3,"sources":["../src/Schema.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["export class Schema {\n    constructor(schema) {\n        this.spec = schema;\n    }\n    getFieldType(fieldName) {\n        var _a;\n        return (_a = this.spec) === null || _a === void 0 ? void 0 : _a[fieldName];\n    }\n    getKeys() {\n        return Object.keys(this.spec);\n    }\n    setSchemaOptionsForAllType(data) {\n        if (data === this.data) {\n            return;\n        }\n        Object.entries(this.spec).forEach(([key, type]) => {\n            type.setSchemaOptions(this.spec, data === null || data === void 0 ? void 0 : data[key]);\n        });\n        this.data = data;\n    }\n    checkForField(fieldName, data) {\n        this.setSchemaOptionsForAllType(data);\n        const fieldChecker = this.spec[fieldName];\n        if (!fieldChecker) {\n            // fieldValue can be anything if no schema defined\n            return { hasError: false };\n        }\n        return fieldChecker.check(data[fieldName], data, fieldName);\n    }\n    checkForFieldAsync(fieldName, data) {\n        this.setSchemaOptionsForAllType(data);\n        const fieldChecker = this.spec[fieldName];\n        if (!fieldChecker) {\n            // fieldValue can be anything if no schema defined\n            return Promise.resolve({ hasError: false });\n        }\n        return fieldChecker.checkAsync(data[fieldName], data, fieldName);\n    }\n    check(data) {\n        const checkResult = {};\n        Object.keys(this.spec).forEach(key => {\n            if (typeof data === 'object') {\n                checkResult[key] = this.checkForField(key, data);\n            }\n        });\n        return checkResult;\n    }\n    checkAsync(data) {\n        const checkResult = {};\n        const promises = [];\n        const keys = [];\n        Object.keys(this.spec).forEach((key) => {\n            keys.push(key);\n            promises.push(this.checkForFieldAsync(key, data));\n        });\n        return Promise.all(promises).then(values => {\n            for (let i = 0; i < values.length; i += 1) {\n                checkResult[keys[i]] = values[i];\n            }\n            return checkResult;\n        });\n    }\n}\nexport function SchemaModel(o) {\n    return new Schema(o);\n}\nSchemaModel.combine = function combine(...specs) {\n    return new Schema(specs\n        .map(model => model.spec)\n        .reduce((accumulator, currentValue) => Object.assign(accumulator, currentValue), {}));\n};\n//# sourceMappingURL=Schema.js.map"]},"metadata":{},"sourceType":"module"}