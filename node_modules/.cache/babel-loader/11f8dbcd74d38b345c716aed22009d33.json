{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.deleteFile = deleteFile, exports.writeMetadataToDb = writeMetadataToDb, exports.uploadFileWithProgress = uploadFileWithProgress;\n\nvar _isUndefined2 = _interopRequireDefault(require(\"lodash/isUndefined\")),\n    _omitBy2 = _interopRequireDefault(require(\"lodash/omitBy\")),\n    _constants = require(\"../constants\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar FILE_UPLOAD_ERROR = _constants.actionTypes.FILE_UPLOAD_ERROR,\n    FILE_UPLOAD_PROGRESS = _constants.actionTypes.FILE_UPLOAD_PROGRESS;\n\nfunction deleteFile(firebase, _ref) {\n  var path = _ref.path,\n      dbPath = _ref.dbPath;\n  return firebase.storage().ref(path).delete().then(function () {\n    if (!dbPath || !firebase.database && !firebase.firestore) return {\n      path: path\n    };\n    return function metaDeletePromise() {\n      return firebase._.config.useFirestoreForStorageMeta ? firebase.firestore().doc(dbPath).delete() : firebase.database().ref(dbPath).remove();\n    }().then(function () {\n      return {\n        path: path,\n        dbPath: dbPath\n      };\n    });\n  });\n}\n\nfunction createUploadMetaResponseHandler(_ref2) {\n  var fileData = _ref2.fileData,\n      firebase = _ref2.firebase,\n      uploadTaskSnapshot = _ref2.uploadTaskSnapshot,\n      downloadURL = _ref2.downloadURL;\n  return function (metaDataSnapshot) {\n    var useFirestoreForStorageMeta = firebase._.config.useFirestoreForStorageMeta,\n        result = {\n      snapshot: metaDataSnapshot,\n      key: metaDataSnapshot.key || metaDataSnapshot.id,\n      File: fileData,\n      metaDataSnapshot: metaDataSnapshot,\n      uploadTaskSnapshot: uploadTaskSnapshot,\n      uploadTaskSnaphot: uploadTaskSnapshot,\n      createdAt: useFirestoreForStorageMeta ? firebase.firestore.FieldValue.serverTimestamp() : firebase.database.ServerValue.TIMESTAMP\n    };\n    return metaDataSnapshot.id && (result.id = metaDataSnapshot.id), downloadURL && (result.downloadURL = downloadURL), result;\n  };\n}\n\nfunction getDownloadURLFromUploadTaskSnapshot(uploadTaskSnapshot) {\n  return uploadTaskSnapshot.ref && \"function\" == typeof uploadTaskSnapshot.ref.getDownloadURL ? uploadTaskSnapshot.ref.getDownloadURL() : Promise.resolve(uploadTaskSnapshot.downloadURLs && uploadTaskSnapshot.downloadURLs[0]);\n}\n\nfunction writeMetadataToDb(_ref3) {\n  var firebase = _ref3.firebase,\n      uploadTaskSnapshot = _ref3.uploadTaskSnapshot,\n      dbPath = _ref3.dbPath,\n      options = _ref3.options,\n      _firebase$_$config = firebase._.config,\n      fileMetadataFactory = _firebase$_$config.fileMetadataFactory,\n      useFirestoreForStorageMeta = _firebase$_$config.useFirestoreForStorageMeta,\n      metadataFactory = options.metadataFactory,\n      documentId = options.documentId,\n      useSetForMetadata = options.useSetForMetadata,\n      metaFactoryFunction = metadataFactory || fileMetadataFactory;\n  return getDownloadURLFromUploadTaskSnapshot(uploadTaskSnapshot).then(function (downloadURL) {\n    var fileData = \"function\" == typeof metaFactoryFunction ? metaFactoryFunction(uploadTaskSnapshot, firebase, uploadTaskSnapshot.metadata, downloadURL) : (0, _omitBy2.default)(uploadTaskSnapshot.metadata, _isUndefined2.default),\n        resultFromSnap = createUploadMetaResponseHandler({\n      fileData: fileData,\n      firebase: firebase,\n      uploadTaskSnapshot: uploadTaskSnapshot,\n      downloadURL: downloadURL\n    }),\n        documentIdFromOptions = \"function\" == typeof documentId ? documentId(uploadTaskSnapshot, firebase, uploadTaskSnapshot.metadata, downloadURL) : documentId;\n    return function metaSetPromise(fileData) {\n      if (useFirestoreForStorageMeta) {\n        if (documentIdFromOptions) {\n          var docRef = firebase.firestore().collection(dbPath).doc(documentIdFromOptions);\n          return !1 === useSetForMetadata ? docRef.update(fileData).then(function () {\n            return docRef;\n          }) : docRef.set(fileData, {\n            merge: !0\n          }).then(function () {\n            return docRef;\n          });\n        }\n\n        return firebase.firestore().collection(dbPath).add(fileData);\n      }\n\n      var newMetaRef = firebase.database().ref(dbPath).push();\n      return newMetaRef.set(fileData).then(function () {\n        return newMetaRef;\n      });\n    }(fileData).then(resultFromSnap);\n  });\n}\n\nfunction uploadFileWithProgress(dispatch, firebase, _ref4) {\n  var path = _ref4.path,\n      file = _ref4.file,\n      filename = _ref4.filename,\n      meta = _ref4.meta,\n      fileMetadata = _ref4.fileMetadata,\n      uploadEvent = firebase.storage().ref(\"\".concat(path, \"/\").concat(filename)).put(file, fileMetadata),\n      unListen = uploadEvent.on(firebase.storage.TaskEvent.STATE_CHANGED, {\n    next: function next(snapshot) {\n      dispatch({\n        type: FILE_UPLOAD_PROGRESS,\n        meta: meta,\n        payload: {\n          snapshot: snapshot,\n          percent: Math.floor(100 * (snapshot.bytesTransferred / snapshot.totalBytes))\n        }\n      });\n    },\n    error: function error(err) {\n      dispatch({\n        type: FILE_UPLOAD_ERROR,\n        meta: meta,\n        payload: err\n      }), unListen();\n    },\n    complete: function complete() {\n      unListen();\n    }\n  });\n  return uploadEvent;\n}","map":{"version":3,"sources":["../../src/utils/storage.js"],"names":["FILE_UPLOAD_ERROR","FILE_UPLOAD_PROGRESS","actionTypes","path","dbPath","firebase","metaDeletePromise","fileData","uploadTaskSnapshot","downloadURL","useFirestoreForStorageMeta","result","snapshot","key","metaDataSnapshot","File","uploadTaskSnaphot","createdAt","id","Promise","options","fileMetadataFactory","metadataFactory","documentId","useSetForMetadata","metaFactoryFunction","getDownloadURLFromUploadTaskSnapshot","resultFromSnap","createUploadMetaResponseHandler","documentIdFromOptions","metaSetPromise","docRef","merge","newMetaRef","file","filename","meta","fileMetadata","uploadEvent","unListen","next","dispatch","type","payload","percent","Math","error","complete"],"mappings":"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","sourcesContent":["import { omitBy, isUndefined } from 'lodash'\nimport { actionTypes } from '../constants'\n\nconst { FILE_UPLOAD_ERROR, FILE_UPLOAD_PROGRESS } = actionTypes\n\n/**\n * Delete file from Firebase Storage with support for deleteing meta\n * data from database (either Real Time Database or Firestore depending on\n * config)\n * @param {object} firebase - Internal firebase object\n * @param {object} settings - Settings object\n * @param {string} settings.path - Path to File which should be deleted\n * @param {string} settings.dbPath - Path of meta data with Database (Real Time Or\n * Firestore depnding on config)\n * @returns {Promise} Resolves with path and dbPath\n */\nexport function deleteFile(firebase, { path, dbPath }) {\n  return firebase\n    .storage()\n    .ref(path)\n    .delete()\n    .then(() => {\n      // return path if dbPath or a database does not exist\n      if (!dbPath || (!firebase.database && !firebase.firestore)) {\n        return { path }\n      }\n\n      // Choose delete function based on config (Handling Firestore and RTDB)\n      const metaDeletePromise = () =>\n        firebase._.config.useFirestoreForStorageMeta\n          ? firebase.firestore().doc(dbPath).delete() // file meta in Firestore\n          : firebase.database().ref(dbPath).remove() // file meta in RTDB\n\n      return metaDeletePromise().then(() => ({ path, dbPath }))\n    })\n}\n\n/**\n * Create a function to handle response from upload.\n * @param {object} settings - Settings object\n * @param {object} settings.fileData - File data which was uploaded\n * @param {object} settings.uploadTaskSnapshot - Snapshot from storage upload task\n * @returns {Function} Function for handling upload result\n */\nfunction createUploadMetaResponseHandler({\n  fileData,\n  firebase,\n  uploadTaskSnapshot,\n  downloadURL\n}) {\n  /**\n   * Converts upload meta data snapshot into an object (handling both\n   * RTDB and Firestore)\n   * @param  {object} metaDataSnapshot - Snapshot from metadata upload (from\n   * RTDB or Firestore)\n   * @returns {object} Upload result including snapshot, key, File\n   */\n  return function uploadResultFromSnap(metaDataSnapshot) {\n    const { useFirestoreForStorageMeta } = firebase._.config\n    const result = {\n      snapshot: metaDataSnapshot,\n      key: metaDataSnapshot.key || metaDataSnapshot.id,\n      File: fileData,\n      metaDataSnapshot,\n      uploadTaskSnapshot,\n      // Support legacy method\n      uploadTaskSnaphot: uploadTaskSnapshot,\n      createdAt: useFirestoreForStorageMeta\n        ? firebase.firestore.FieldValue.serverTimestamp()\n        : firebase.database.ServerValue.TIMESTAMP\n    }\n    // Attach id if it exists (Firestore)\n    if (metaDataSnapshot.id) {\n      result.id = metaDataSnapshot.id\n    }\n    // Attach downloadURL if it exists\n    if (downloadURL) {\n      result.downloadURL = downloadURL\n    }\n    return result\n  }\n}\n\n/**\n * Get download URL from upload task snapshot\n * @param {firebase.storage.UploadTaskSnapshot} uploadTaskSnapshot - Upload task snapshot\n * @returns {Promise} Resolves with download URL\n */\nfunction getDownloadURLFromUploadTaskSnapshot(uploadTaskSnapshot) {\n  // Handle different downloadURL patterns (Firebase JS SDK v5.*.* vs v4.*.*)\n  if (\n    uploadTaskSnapshot.ref &&\n    typeof uploadTaskSnapshot.ref.getDownloadURL === 'function'\n  ) {\n    // Get downloadURL and attach to response\n    return uploadTaskSnapshot.ref.getDownloadURL()\n  }\n  // Only attach downloadURL if downloadURLs is defined (not defined in v5.*.*)\n  return Promise.resolve(\n    uploadTaskSnapshot.downloadURLs && uploadTaskSnapshot.downloadURLs[0]\n  )\n}\n\n/**\n * Write file metadata to Database (either Real Time Datbase or Firestore\n * depending on config).\n * @param {object} settings - Settings object\n * @param {object} settings.firebase - Internal firebase object\n * @param {object} settings.uploadTaskSnapshot - Snapshot from upload task\n * @param {string} settings.dbPath - Path of meta data with Database (Real Time Or\n * Firestore depnding on config)\n * @returns {Promise} Resolves with payload (includes snapshot, File, and\n * metaDataSnapshot)\n */\nexport function writeMetadataToDb({\n  firebase,\n  uploadTaskSnapshot,\n  dbPath,\n  options\n}) {\n  // Support metadata factories from both global config and options\n  const { fileMetadataFactory, useFirestoreForStorageMeta } = firebase._.config\n  const { metadataFactory, documentId, useSetForMetadata } = options\n  const metaFactoryFunction = metadataFactory || fileMetadataFactory\n  // Get download URL for use in metadata write\n  return getDownloadURLFromUploadTaskSnapshot(uploadTaskSnapshot).then(\n    (downloadURL) => {\n      // Apply fileMetadataFactory if it exists in config\n      const fileData =\n        typeof metaFactoryFunction === 'function'\n          ? metaFactoryFunction(\n              uploadTaskSnapshot,\n              firebase,\n              uploadTaskSnapshot.metadata,\n              downloadURL\n            )\n          : omitBy(uploadTaskSnapshot.metadata, isUndefined)\n\n      // Create the snapshot handler function\n      const resultFromSnap = createUploadMetaResponseHandler({\n        fileData,\n        firebase,\n        uploadTaskSnapshot,\n        downloadURL\n      })\n\n      // Function for creating promise for writing file metadata (handles writing to RTDB or Firestore)\n      const documentIdFromOptions =\n        typeof documentId === 'function'\n          ? documentId(\n              uploadTaskSnapshot,\n              firebase,\n              uploadTaskSnapshot.metadata,\n              downloadURL\n            )\n          : documentId\n      const metaSetPromise = (fileData) => {\n        if (useFirestoreForStorageMeta) {\n          if (documentIdFromOptions) {\n            const docRef = firebase // Write metadata to Firestore\n              .firestore()\n              .collection(dbPath)\n              .doc(documentIdFromOptions)\n            return useSetForMetadata === false\n              ? docRef.update(fileData).then(() => docRef)\n              : docRef.set(fileData, { merge: true }).then(() => docRef)\n          }\n          return firebase.firestore().collection(dbPath).add(fileData)\n        }\n        // Create new reference for metadata\n        const newMetaRef = firebase.database().ref(dbPath).push()\n        // Write metadata to Real Time Database and return new meta ref\n        return newMetaRef.set(fileData).then((res) => newMetaRef)\n      }\n\n      return metaSetPromise(fileData).then(resultFromSnap)\n    }\n  )\n}\n\n/**\n * Upload a file with actions fired for progress, success, and errors\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} opts - File data object\n * @param {object} opts.path - Location within Firebase Stroage at which to upload file.\n * @param {Blob} opts.file - File to upload\n * @param {object} opts.fileMetadata - Metadata to pass along to storageRef.put call\n * @returns {Promise} Promise which resolves after file upload\n * @private\n */\nexport function uploadFileWithProgress(\n  dispatch,\n  firebase,\n  { path, file, filename, meta, fileMetadata }\n) {\n  const uploadEvent = firebase\n    .storage()\n    .ref(`${path}/${filename}`)\n    .put(file, fileMetadata)\n\n  const unListen = uploadEvent.on(firebase.storage.TaskEvent.STATE_CHANGED, {\n    next: (snapshot) => {\n      dispatch({\n        type: FILE_UPLOAD_PROGRESS,\n        meta,\n        payload: {\n          snapshot,\n          percent: Math.floor(\n            (snapshot.bytesTransferred / snapshot.totalBytes) * 100\n          )\n        }\n      })\n    },\n    error: (err) => {\n      dispatch({ type: FILE_UPLOAD_ERROR, meta, payload: err })\n      unListen()\n    },\n    complete: () => {\n      unListen()\n    }\n  })\n  return uploadEvent\n}\n"]},"metadata":{},"sourceType":"script"}