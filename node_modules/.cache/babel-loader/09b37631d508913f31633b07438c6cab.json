{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.unWatchUserProfile = unWatchUserProfile, exports.handleProfileWatchResponse = handleProfileWatchResponse, exports.linkAndRetrieveDataWithCredential = linkAndRetrieveDataWithCredential, exports.linkWithPopup = linkWithPopup, exports.linkWithRedirect = linkWithRedirect, exports.signInWithPhoneNumber = signInWithPhoneNumber, exports.linkWithCredential = exports.reloadAuth = exports.updateEmail = exports.updateAuth = exports.updateProfile = exports.applyActionCode = exports.verifyPasswordResetCode = exports.confirmPasswordReset = exports.resetPassword = exports.createUser = exports.logout = exports.reauthenticate = exports.login = exports.init = exports.handleRedirectResult = exports.createUserProfile = exports.watchUserProfile = void 0;\n\nvar _pick2 = _interopRequireDefault(require(\"lodash/pick\")),\n    _omit2 = _interopRequireDefault(require(\"lodash/omit\")),\n    _forEach2 = _interopRequireDefault(require(\"lodash/forEach\")),\n    _constants = require(\"../constants\"),\n    _helpers = require(\"../helpers\"),\n    _utils = require(\"../utils\"),\n    _auth = require(\"../utils/auth\"),\n    _populate = require(\"../utils/populate\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (o) {\n    if (\"string\" == typeof o) return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    return \"Object\" === n && o.constructor && (n = o.constructor.name), \"Map\" === n || \"Set\" === n ? Array.from(o) : \"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? _arrayLikeToArray(o, minLen) : void 0;\n  }\n}\n\nfunction _iterableToArray(iter) {\n  if (\"undefined\" != typeof Symbol && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  (null == len || len > arr.length) && (len = arr.length);\n\n  for (var i = 0, arr2 = Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var source, i = 1; i < arguments.length; i++) source = null == arguments[i] ? {} : arguments[i], i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n    _defineProperty(target, key, source[key]);\n  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n  });\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  return key in obj ? Object.defineProperty(obj, key, {\n    value: value,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : obj[key] = value, obj;\n}\n\nfunction dispatchLoginError(dispatch, authError) {\n  var params = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : {};\n  return dispatch(_objectSpread(_objectSpread({\n    type: _constants.actionTypes.LOGIN_ERROR\n  }, params), {}, {\n    authError: authError\n  }));\n}\n\nfunction unWatchUserProfile(firebase) {\n  var _firebase$_ = firebase._,\n      authUid = _firebase$_.authUid,\n      _firebase$_$config = _firebase$_.config,\n      userProfile = _firebase$_$config.userProfile,\n      useFirestoreForProfile = _firebase$_$config.useFirestoreForProfile;\n  firebase._.profileWatch && (useFirestoreForProfile && firebase.firestore ? firebase._.profileWatch() : userProfile && firebase.database && firebase.database().ref().child(\"\".concat(userProfile, \"/\").concat(authUid)).off(\"value\", firebase._.profileWatch), firebase._.profileWatch = null);\n}\n\nfunction getProfileFromSnap(snap) {\n  return snap && snap.val ? snap.val() : snap && snap.data && snap.exists ? snap.data() : null;\n}\n\nfunction handleProfileWatchResponse(dispatch, firebase, userProfileSnap, token) {\n  var _firebase$_$config2 = firebase._.config,\n      profileParamsToPopulate = _firebase$_$config2.profileParamsToPopulate,\n      autoPopulateProfile = _firebase$_$config2.autoPopulateProfile,\n      useFirestoreForProfile = _firebase$_$config2.useFirestoreForProfile,\n      logErrors = _firebase$_$config2.logErrors,\n      profile = getProfileFromSnap(userProfileSnap);\n  profileParamsToPopulate && !useFirestoreForProfile && (Array.isArray(profileParamsToPopulate) || (0, _utils.isString)(profileParamsToPopulate)) ? (0, _populate.promisesForPopulate)(firebase, userProfileSnap.key, profile, profileParamsToPopulate).then(function (data) {\n    if ((0, _forEach2.default)(data, function (result, path) {\n      dispatch({\n        type: _constants.actionTypes.SET,\n        path: path,\n        data: result,\n        timestamp: Date.now(),\n        requesting: !1,\n        requested: !0\n      });\n    }), !autoPopulateProfile) dispatch({\n      type: _constants.actionTypes.SET_PROFILE,\n      profile: token ? _objectSpread(_objectSpread({}, profile), {}, {\n        token: token\n      }) : profile\n    });else {\n      var populates = (0, _populate.getPopulateObjs)(profileParamsToPopulate),\n          _profile = userProfileSnap.val();\n\n      dispatch({\n        type: _constants.actionTypes.SET_PROFILE,\n        profile: (0, _helpers.populate)({\n          profile: token ? _objectSpread(_objectSpread({}, _profile), {}, {\n            token: token\n          }) : _profile,\n          data: data\n        }, \"profile\", populates)\n      });\n    }\n  }).catch(function (err) {\n    logErrors && console.error(\"RRF: Error retrieving data for profile population. Firebase:\", err), dispatch({\n      type: _constants.actionTypes.UNAUTHORIZED_ERROR,\n      authError: \"Error during profile population: \".concat(err.message)\n    }), dispatch({\n      type: _constants.actionTypes.SET_PROFILE,\n      profile: profile\n    });\n  }) : (useFirestoreForProfile && profileParamsToPopulate && console.warn(\"Profile population is not yet supported for Firestore\"), dispatch({\n    type: _constants.actionTypes.SET_PROFILE,\n    profile: token ? _objectSpread(_objectSpread({}, profile), {}, {\n      token: token\n    }) : profile\n  }));\n}\n\nfunction createProfileWatchErrorHandler(dispatch, firebase) {\n  var _firebase$_$config3 = firebase._.config,\n      onProfileListenerError = _firebase$_$config3.onProfileListenerError,\n      logErrors = _firebase$_$config3.logErrors;\n  return function (err) {\n    if (logErrors && console.error(\"Error with profile listener: \".concat(err.message || \"\"), err), \"function\" == typeof onProfileListenerError) {\n      var factoryResult = onProfileListenerError(err, firebase);\n      if (\"function\" == typeof factoryResult.then) return factoryResult;\n    }\n\n    return Promise.reject(err);\n  };\n}\n\nvar watchUserProfile = function (dispatch, firebase) {\n  var _firebase$_2 = firebase._,\n      authUid = _firebase$_2.authUid,\n      _firebase$_2$config = _firebase$_2.config,\n      userProfile = _firebase$_2$config.userProfile,\n      useFirestoreForProfile = _firebase$_2$config.useFirestoreForProfile,\n      enableClaims = _firebase$_2$config.enableClaims;\n  if (unWatchUserProfile(firebase), !userProfile) enableClaims && (firebase._.profileWatch = firebase.auth().currentUser.getIdTokenResult(!0).then(function (token) {\n    dispatch({\n      type: _constants.actionTypes.SET_PROFILE,\n      profile: {\n        token: token\n      }\n    });\n  }));else if (useFirestoreForProfile && firebase.firestore) firebase._.profileWatch = firebase.firestore().collection(userProfile).doc(authUid).onSnapshot(function (userProfileSnap) {\n    return enableClaims ? firebase.auth().currentUser.getIdTokenResult(!0).then(function (token) {\n      return handleProfileWatchResponse(dispatch, firebase, userProfileSnap, token);\n    }) : handleProfileWatchResponse(dispatch, firebase, userProfileSnap, null);\n  }, createProfileWatchErrorHandler(dispatch, firebase));else if (firebase.database) firebase._.profileWatch = firebase.database().ref().child(\"\".concat(userProfile, \"/\").concat(authUid)).on(\"value\", function (userProfileSnap) {\n    enableClaims ? firebase.auth().currentUser.getIdTokenResult(!0).then(function (token) {\n      return handleProfileWatchResponse(dispatch, firebase, userProfileSnap, token);\n    }) : handleProfileWatchResponse(dispatch, firebase, userProfileSnap, null);\n  }, createProfileWatchErrorHandler(dispatch, firebase));else throw new Error(\"Real Time Database or Firestore must be included to enable user profile\");\n};\n\nexports.watchUserProfile = watchUserProfile;\n\nvar createUserProfile = function (dispatch, firebase, userData, profile) {\n  var config = firebase._.config;\n  if (!config.userProfile || !firebase.database && !firebase.firestore) return Promise.resolve(userData);\n  if (\"function\" == typeof config.profileFactory) try {\n    profile = config.profileFactory(userData, profile, firebase);\n  } catch (err) {\n    return console.error(\"Error occurred within profileFactory function:\", err.message || err), Promise.reject(err);\n  }\n  return config.useFirestoreForProfile ? firebase.firestore().collection(config.userProfile).doc(userData.uid || userData.user.uid).get().then(function (profileSnap) {\n    if (!config.updateProfileOnLogin && profileSnap.exists) return profileSnap.data();\n    var newProfile = profile;\n\n    if (!newProfile) {\n      var userDataObject = userData.uid ? userData.toJSON ? userData.toJSON() : userData : userData.user.toJSON ? userData.user.toJSON() : userData.user;\n      newProfile = _objectSpread(_objectSpread({}, (0, _omit2.default)(userDataObject, config.keysToRemoveFromAuth)), {}, {\n        avatarUrl: userDataObject.photoURL\n      });\n    }\n\n    return Array.isArray(newProfile.providerData) && (newProfile.providerData = newProfile.providerData.map(function (providerDataItem) {\n      return (0, _pick2.default)(providerDataItem, config.keysToPreserveFromProviderData);\n    })), profileSnap.ref.set(newProfile, {\n      merge: !0\n    }).then(function () {\n      return newProfile;\n    });\n  }).catch(function (err) {\n    return dispatch({\n      type: _constants.actionTypes.UNAUTHORIZED_ERROR,\n      authError: err\n    }), Promise.reject(err);\n  }) : firebase.database().ref().child(\"\".concat(config.userProfile, \"/\").concat(userData.user ? userData.user.uid : userData.uid)).once(\"value\").then(function (profileSnap) {\n    return config.updateProfileOnLogin || null === profileSnap.val() ? profileSnap.ref.update(profile).then(function () {\n      return profile;\n    }) : profileSnap.val();\n  }).catch(function (err) {\n    return dispatch({\n      type: _constants.actionTypes.UNAUTHORIZED_ERROR,\n      authError: err\n    }), \"function\" == typeof config.onProfileWriteError && config.onProfileWriteError(err, firebase), Promise.reject(err);\n  });\n};\n\nexports.createUserProfile = createUserProfile;\n\nvar handleAuthStateChange = function (dispatch, firebase, authData) {\n  var config = firebase._.config;\n  authData ? (firebase._.authUid = authData.uid, config.presence && (0, _auth.setupPresence)(dispatch, firebase), dispatch({\n    type: _constants.actionTypes.LOGIN,\n    auth: authData,\n    preserve: config.preserveOnLogin\n  }), watchUserProfile(dispatch, firebase), \"function\" == typeof config.onAuthStateChanged && config.onAuthStateChanged(authData, firebase, dispatch)) : (\"function\" == typeof config.onAuthStateChanged && firebase._.config.onAuthStateChanged(authData, firebase, dispatch), dispatch({\n    type: _constants.actionTypes.AUTH_EMPTY_CHANGE,\n    preserve: config.preserveOnEmptyAuthChange\n  }), unWatchUserProfile(firebase));\n},\n    handleRedirectResult = function (dispatch, firebase, authData) {\n  if (\"function\" == typeof firebase._.config.onRedirectResult && firebase._.config.onRedirectResult(authData, firebase, dispatch), authData && authData.user) {\n    var user = authData.user;\n    return firebase._.authUid = user.uid, watchUserProfile(dispatch, firebase), dispatch({\n      type: _constants.actionTypes.LOGIN,\n      auth: user,\n      preserve: firebase._.config.preserveOnLogin\n    }), createUserProfile(dispatch, firebase, user, {\n      email: user.email,\n      displayName: user.providerData[0].displayName || user.email,\n      avatarUrl: user.providerData[0].photoURL,\n      providerData: user.providerData\n    });\n  }\n};\n\nexports.handleRedirectResult = handleRedirectResult;\n\nvar init = function (dispatch, firebase) {\n  firebase.auth && (dispatch({\n    type: _constants.actionTypes.AUTHENTICATION_INIT_STARTED\n  }), firebase.auth().onAuthStateChanged(function (authData) {\n    return handleAuthStateChange(dispatch, firebase, authData);\n  }), firebase._.config.enableRedirectHandling && \"function\" == typeof firebase.auth().getRedirectResult && \"undefined\" != typeof window && window.location && window.location.protocol && -1 !== window.location.protocol.indexOf(\"http\") && firebase.auth().getRedirectResult().then(function (authData) {\n    return handleRedirectResult(dispatch, firebase, authData);\n  }).catch(function (error) {\n    return dispatchLoginError(dispatch, error), Promise.reject(error);\n  }), firebase.auth().currentUser, dispatch({\n    type: _constants.actionTypes.AUTHENTICATION_INIT_FINISHED\n  }));\n};\n\nexports.init = init;\n\nvar login = function (dispatch, firebase, credentials) {\n  var _firebase$auth;\n\n  firebase._.config.resetBeforeLogin && dispatchLoginError(dispatch, null);\n\n  var _getLoginMethodAndPar = (0, _auth.getLoginMethodAndParams)(firebase, credentials),\n      method = _getLoginMethodAndPar.method,\n      params = _getLoginMethodAndPar.params;\n\n  return (_firebase$auth = firebase.auth())[method].apply(_firebase$auth, _toConsumableArray(params)).then(function (userData) {\n    if (!userData) return Promise.resolve(null);\n    if ([\"signInWithEmailAndPassword\", \"signInAndRetrieveDataWithEmailAndPassword\"].includes(method)) return {\n      user: userData\n    };\n    if ([\"signInWithCustomToken\", \"signInAndRetrieveDataWithCustomToken\"].includes(method)) return firebase._.config.updateProfileOnLogin ? createUserProfile(dispatch, firebase, userData, credentials.profile) : {\n      user: userData\n    };\n    if (\"signInWithPhoneNumber\" === method) return _objectSpread(_objectSpread({}, userData), {}, {\n      confirm: function confirm(code) {\n        return userData.confirm(code).then(function (_ref) {\n          var user = _ref.user,\n              additionalUserInfo = _ref.additionalUserInfo;\n          return createUserProfile(dispatch, firebase, user, {\n            phoneNumber: user.providerData[0].phoneNumber,\n            providerData: user.providerData\n          }).then(function (profile) {\n            return {\n              profile: profile,\n              user: user,\n              additionalUserInfo: additionalUserInfo\n            };\n          });\n        });\n      }\n    });\n    var user = userData.user || userData;\n    return createUserProfile(dispatch, firebase, user, credentials.profile || {\n      email: user.email,\n      displayName: user.providerData[0].displayName || user.email,\n      avatarUrl: user.providerData[0].photoURL,\n      providerData: user.providerData\n    }).then(function (profile) {\n      return _objectSpread({\n        profile: profile\n      }, userData);\n    });\n  }).catch(function (err) {\n    return dispatchLoginError(dispatch, err), Promise.reject(err);\n  });\n};\n\nexports.login = login;\n\nvar reauthenticate = function (dispatch, firebase, credentials) {\n  var _firebase$auth$curren,\n      _getReauthenticateMet = (0, _auth.getReauthenticateMethodAndParams)(firebase, credentials),\n      method = _getReauthenticateMet.method,\n      params = _getReauthenticateMet.params;\n\n  return (_firebase$auth$curren = firebase.auth().currentUser)[method].apply(_firebase$auth$curren, _toConsumableArray(params)).then(function (userData) {\n    if (!userData) return Promise.resolve(null);\n    if (\"reauthenticateWithPhoneNumber\" === method) return _objectSpread(_objectSpread({}, userData), {}, {\n      confirm: function confirm(code) {\n        return userData.confirm(code).then(function (_ref2) {\n          var user = _ref2.user,\n              additionalUserInfo = _ref2.additionalUserInfo;\n          return createUserProfile(dispatch, firebase, user, {\n            phoneNumber: user.providerData[0].phoneNumber,\n            providerData: user.providerData\n          }).then(function (profile) {\n            return {\n              profile: profile,\n              user: user,\n              additionalUserInfo: additionalUserInfo\n            };\n          });\n        });\n      }\n    });\n    var user = userData.user || userData;\n    return createUserProfile(dispatch, firebase, user, credentials.profile || {\n      email: user.email,\n      displayName: user.providerData[0].displayName || user.email,\n      avatarUrl: user.providerData[0].photoURL,\n      providerData: user.providerData\n    }).then(function (profile) {\n      return _objectSpread({\n        profile: profile\n      }, userData);\n    });\n  }).catch(function (err) {\n    return dispatchLoginError(dispatch, err, {\n      reauthenticate: !0\n    }), Promise.reject(err);\n  });\n};\n\nexports.reauthenticate = reauthenticate;\n\nvar logout = function (dispatch, firebase) {\n  return unWatchUserProfile(firebase), firebase.auth().signOut().then(function () {\n    var action = {\n      type: _constants.actionTypes.LOGOUT\n    };\n    return firebase._.config.preserveOnLogout && (action.preserve = firebase._.config.preserveOnLogout), dispatch(action), firebase._.authUid = null, firebase;\n  });\n};\n\nexports.logout = logout;\n\nvar createUser = function (dispatch, firebase, _ref3, profile) {\n  var email = _ref3.email,\n      password = _ref3.password;\n\n  if (dispatchLoginError(dispatch, null), !email || !password) {\n    var error = new Error(\"Email and Password are required to create user\");\n    return dispatchLoginError(dispatch, error), Promise.reject(error);\n  }\n\n  return firebase.auth().createUserWithEmailAndPassword(email, password).then(function (userData) {\n    return createUserProfile(dispatch, firebase, userData, profile || {\n      email: email\n    });\n  }).catch(function (err) {\n    return dispatchLoginError(dispatch, err), Promise.reject(err);\n  });\n};\n\nexports.createUser = createUser;\n\nvar resetPassword = function (dispatch, firebase, email) {\n  return dispatchLoginError(dispatch, null), firebase.auth().sendPasswordResetEmail(email).catch(function (err) {\n    if (err) {\n      switch (err.code) {\n        case \"auth/user-not-found\":\n          dispatchLoginError(dispatch, _objectSpread(_objectSpread({}, err), {}, {\n            message: \"The specified user account does not exist.\"\n          }));\n          break;\n\n        default:\n          dispatchLoginError(dispatch, err);\n      }\n\n      return Promise.reject(err);\n    }\n  });\n};\n\nexports.resetPassword = resetPassword;\n\nvar confirmPasswordReset = function (dispatch, firebase, code, password) {\n  return dispatchLoginError(dispatch, null), firebase.auth().confirmPasswordReset(code, password).catch(function (err) {\n    if (err) {\n      switch (err.code) {\n        case \"auth/expired-action-code\":\n          dispatchLoginError(dispatch, new Error(\"The action code has expired.\"));\n          break;\n\n        case \"auth/invalid-action-code\":\n          dispatchLoginError(dispatch, new Error(\"The action code is invalid.\"));\n          break;\n\n        case \"auth/user-disabled\":\n          dispatchLoginError(dispatch, new Error(\"The user is disabled.\"));\n          break;\n\n        case \"auth/user-not-found\":\n          dispatchLoginError(dispatch, new Error(\"The user is not found.\"));\n          break;\n\n        case \"auth/weak-password\":\n          dispatchLoginError(dispatch, new Error(\"The password is not strong enough.\"));\n          break;\n\n        default:\n          dispatchLoginError(dispatch, err);\n      }\n\n      return Promise.reject(err);\n    }\n  });\n};\n\nexports.confirmPasswordReset = confirmPasswordReset;\n\nvar verifyPasswordResetCode = function (dispatch, firebase, code) {\n  return dispatchLoginError(dispatch, null), firebase.auth().verifyPasswordResetCode(code).catch(function (err) {\n    return err && dispatchLoginError(dispatch, err), Promise.reject(err);\n  });\n};\n\nexports.verifyPasswordResetCode = verifyPasswordResetCode;\n\nvar applyActionCode = function (dispatch, firebase, code) {\n  return dispatchLoginError(dispatch, null), firebase.auth().applyActionCode(code).catch(function (err) {\n    return err && dispatchLoginError(dispatch, err), Promise.reject(err);\n  });\n};\n\nexports.applyActionCode = applyActionCode;\n\nvar updateProfile = function (dispatch, firebase, profileUpdate, options) {\n  var config = firebase._.config;\n  dispatch({\n    type: _constants.actionTypes.PROFILE_UPDATE_START,\n    payload: profileUpdate\n  });\n  var updatePromise = config.useFirestoreForProfile ? _auth.updateProfileOnFirestore : _auth.updateProfileOnRTDB;\n  return updatePromise(firebase, profileUpdate, options).then(function (snap) {\n    return dispatch({\n      type: _constants.actionTypes.PROFILE_UPDATE_SUCCESS,\n      payload: config.useFirestoreForProfile ? snap.data() : snap.val()\n    }), snap;\n  }).catch(function (error) {\n    return dispatch({\n      type: _constants.actionTypes.PROFILE_UPDATE_ERROR,\n      error: error\n    }), Promise.reject(error);\n  });\n};\n\nexports.updateProfile = updateProfile;\n\nvar updateAuth = function (dispatch, firebase, authUpdate, updateInProfile) {\n  if (dispatch({\n    type: _constants.actionTypes.AUTH_UPDATE_START,\n    payload: authUpdate\n  }), !firebase.auth().currentUser) {\n    var error = new Error(\"User must be logged in to update auth.\");\n    return dispatch({\n      type: _constants.actionTypes.AUTH_UPDATE_ERROR,\n      payload: error\n    }), Promise.reject(error);\n  }\n\n  return firebase.auth().currentUser.updateProfile(authUpdate).then(function (payload) {\n    return dispatch({\n      type: _constants.actionTypes.AUTH_UPDATE_SUCCESS,\n      auth: firebase.auth().currentUser\n    }), updateInProfile ? updateProfile(dispatch, firebase, authUpdate) : payload;\n  }).catch(function (error) {\n    return dispatch({\n      type: _constants.actionTypes.AUTH_UPDATE_ERROR,\n      error: error\n    }), Promise.reject(error);\n  });\n};\n\nexports.updateAuth = updateAuth;\n\nvar updateEmail = function (dispatch, firebase, newEmail, updateInProfile) {\n  if (dispatch({\n    type: _constants.actionTypes.EMAIL_UPDATE_START,\n    payload: newEmail\n  }), !firebase.auth().currentUser) {\n    var error = new Error(\"User must be logged in to update email.\");\n    return dispatch({\n      type: _constants.actionTypes.EMAIL_UPDATE_ERROR,\n      error: error\n    }), Promise.reject(error);\n  }\n\n  return firebase.auth().currentUser.updateEmail(newEmail).then(function (payload) {\n    return dispatch({\n      type: _constants.actionTypes.EMAIL_UPDATE_SUCCESS,\n      payload: newEmail\n    }), updateInProfile ? updateProfile(dispatch, firebase, {\n      email: newEmail\n    }) : payload;\n  }).catch(function (error) {\n    return dispatch({\n      type: _constants.actionTypes.EMAIL_UPDATE_ERROR,\n      error: error\n    }), Promise.reject(error);\n  });\n};\n\nexports.updateEmail = updateEmail;\n\nvar reloadAuth = function (dispatch, firebase) {\n  if (dispatch({\n    type: _constants.actionTypes.AUTH_RELOAD_START\n  }), !firebase.auth().currentUser) {\n    var error = new Error(\"User must be logged in to reload auth.\");\n    return dispatch({\n      type: _constants.actionTypes.AUTH_RELOAD_ERROR,\n      error: error\n    }), Promise.reject(error);\n  }\n\n  return firebase.auth().currentUser.reload().then(function () {\n    var auth = firebase.auth().currentUser;\n    return dispatch({\n      type: _constants.actionTypes.AUTH_RELOAD_SUCCESS,\n      payload: auth\n    }), auth;\n  }).catch(function (error) {\n    return dispatch({\n      type: _constants.actionTypes.AUTH_RELOAD_ERROR,\n      error: error\n    }), Promise.reject(error);\n  });\n};\n\nexports.reloadAuth = reloadAuth;\n\nvar linkWithCredential = function (dispatch, firebase, credential) {\n  if (dispatch({\n    type: _constants.actionTypes.AUTH_LINK_START\n  }), !firebase.auth().currentUser) {\n    var error = new Error(\"User must be logged in to link with credential.\");\n    return dispatch({\n      type: _constants.actionTypes.AUTH_LINK_ERROR,\n      error: error\n    }), Promise.reject(error);\n  }\n\n  return firebase.auth().currentUser.linkWithCredential(credential).then(function (auth) {\n    return dispatch({\n      type: _constants.actionTypes.AUTH_LINK_SUCCESS,\n      payload: auth\n    }), auth;\n  }).catch(function (error) {\n    return dispatch({\n      type: _constants.actionTypes.AUTH_LINK_ERROR,\n      error: error\n    }), Promise.reject(error);\n  });\n};\n\nexports.linkWithCredential = linkWithCredential;\n\nfunction linkWithAuthDispatch(promiseFunc, args, dispatch, firebase) {\n  if (dispatch({\n    type: _constants.actionTypes.AUTH_LINK_START\n  }), !firebase.auth().currentUser) {\n    var error = new Error(\"User must be logged in to link with credential.\");\n    return dispatch({\n      type: _constants.actionTypes.AUTH_LINK_ERROR,\n      error: error\n    }), Promise.reject(error);\n  }\n\n  return promiseFunc.apply(void 0, _toConsumableArray(args)).then(function (auth) {\n    return dispatch({\n      type: _constants.actionTypes.AUTH_LINK_SUCCESS,\n      payload: auth\n    }), auth;\n  }).catch(function (error) {\n    return dispatch({\n      type: _constants.actionTypes.AUTH_LINK_ERROR,\n      error: error\n    }), Promise.reject(error);\n  });\n}\n\nfunction linkAndRetrieveDataWithCredential(dispatch, firebase, credential) {\n  return linkWithAuthDispatch(firebase.auth().currentUser.linkAndRetrieveDataWithCredential, [credential], dispatch, firebase);\n}\n\nfunction linkWithPopup(dispatch, firebase, credential) {\n  return linkWithAuthDispatch(firebase.auth().currentUser.linkWithPopup, [credential], dispatch, firebase);\n}\n\nfunction linkWithRedirect(dispatch, firebase, provider) {\n  return linkWithAuthDispatch(firebase.auth().currentUser.linkWithRedirect, [provider], dispatch, firebase);\n}\n\nfunction signInWithPhoneNumber(firebase, dispatch, phoneNumber, applicationVerifier) {\n  var options = 4 < arguments.length && arguments[4] !== void 0 ? arguments[4] : {};\n  return login(dispatch, firebase, _objectSpread({\n    phoneNumber: phoneNumber,\n    applicationVerifier: applicationVerifier\n  }, options));\n}","map":{"version":3,"sources":["../../src/actions/auth.js"],"names":["params","dispatch","type","actionTypes","authError","authUid","userProfile","useFirestoreForProfile","firebase","snap","profileParamsToPopulate","autoPopulateProfile","logErrors","profile","getProfileFromSnap","Array","console","token","userProfileSnap","path","data","timestamp","Date","requesting","requested","populates","err","onProfileListenerError","factoryResult","Promise","watchUserProfile","enableClaims","unWatchUserProfile","handleProfileWatchResponse","createProfileWatchErrorHandler","createUserProfile","config","userData","profileSnap","newProfile","userDataObject","avatarUrl","merge","onProfileWriteError","handleAuthStateChange","authData","preserve","auth","handleRedirectResult","onRedirectResult","user","uid","email","displayName","providerData","init","window","dispatchLoginError","login","method","credentials","confirm","additionalUserInfo","phoneNumber","reauthenticate","logout","action","preserveOnLogout","createUser","password","error","resetPassword","message","confirmPasswordReset","verifyPasswordResetCode","applyActionCode","updateProfile","payload","updatePromise","updateProfileOnFirestore","updateProfileOnRTDB","updateAuth","updateInProfile","updateEmail","reloadAuth","linkWithCredential","promiseFunc","linkWithAuthDispatch","options","applicationVerifier"],"mappings":"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","sourcesContent":["import { forEach, omit, pick } from 'lodash'\nimport { actionTypes } from '../constants'\nimport { populate } from '../helpers'\nimport { isString } from '../utils'\nimport {\n  getLoginMethodAndParams,\n  getReauthenticateMethodAndParams,\n  updateProfileOnRTDB,\n  updateProfileOnFirestore,\n  setupPresence\n} from '../utils/auth'\nimport { promisesForPopulate, getPopulateObjs } from '../utils/populate'\n\n/**\n * Dispatch login error action\n * @param {Function} dispatch - Action dispatch function\n * @param {object} authError - Error object\n * @param {object} params - Supplement action params\n * @returns {any} Return of action dispatch\n * @private\n */\nfunction dispatchLoginError(dispatch, authError, params = {}) {\n  return dispatch({\n    type: actionTypes.LOGIN_ERROR,\n    ...params,\n    authError\n  })\n}\n\n/**\n * Remove listener from user profile\n * @param {object} firebase - Internal firebase object\n * @private\n */\nexport function unWatchUserProfile(firebase) {\n  const {\n    authUid,\n    config: { userProfile, useFirestoreForProfile }\n  } = firebase._\n  if (!firebase._.profileWatch) {\n    return\n  }\n  if (useFirestoreForProfile && firebase.firestore) {\n    // Call profile onSnapshot unsubscribe stored on profileWatch\n    firebase._.profileWatch()\n  } else if (userProfile && firebase.database) {\n    firebase\n      .database()\n      .ref()\n      .child(`${userProfile}/${authUid}`)\n      .off('value', firebase._.profileWatch)\n  }\n  firebase._.profileWatch = null\n}\n\n/**\n * @param {firebase.database.Snapshot|firebase.firestore.DocumentSnapshot} snap - Profile snapshot\n * @returns {object|null} Profile from snapshot\n */\nfunction getProfileFromSnap(snap) {\n  // Real Time Database\n  if (snap && snap.val) {\n    return snap.val()\n  }\n  // Firestore\n  if (snap && snap.data && snap.exists) {\n    return snap.data()\n  }\n  return null\n}\n\n/**\n * Handle response from profile listener. Works with both Real Time Database\n * and Cloud Firestore.\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {firebase.database.Snapshot|firebase.firestore.DocumentSnapshot} userProfileSnap - Snapshot from profile watcher\n * @param {string} token - Token to pass along in action dispatch\n * @private\n */\nexport function handleProfileWatchResponse(\n  dispatch,\n  firebase,\n  userProfileSnap,\n  token\n) {\n  const {\n    profileParamsToPopulate,\n    autoPopulateProfile,\n    useFirestoreForProfile,\n    logErrors\n  } = firebase._.config\n  const profile = getProfileFromSnap(userProfileSnap)\n  if (\n    !profileParamsToPopulate ||\n    useFirestoreForProfile || // populating profile through firestore not yet supported\n    (!Array.isArray(profileParamsToPopulate) &&\n      !isString(profileParamsToPopulate))\n  ) {\n    if (useFirestoreForProfile && profileParamsToPopulate) {\n      console.warn('Profile population is not yet supported for Firestore') // eslint-disable-line no-console\n    }\n    dispatch({\n      type: actionTypes.SET_PROFILE,\n      profile: token ? { ...profile, token } : profile\n    })\n  } else {\n    // Convert array of populate config into an array of once query promises\n    promisesForPopulate(\n      firebase,\n      userProfileSnap.key,\n      profile,\n      profileParamsToPopulate\n    )\n      .then((data) => {\n        // Fire actions for placement of data gathered in populate into redux\n        forEach(data, (result, path) => {\n          dispatch({\n            type: actionTypes.SET,\n            path,\n            data: result,\n            timestamp: Date.now(),\n            requesting: false,\n            requested: true\n          })\n        })\n        if (!autoPopulateProfile) {\n          // Dispatch action with profile combined with populated parameters\n          dispatch({\n            type: actionTypes.SET_PROFILE,\n            profile: token ? { ...profile, token } : profile\n          })\n        } else {\n          // Auto Populate profile\n          const populates = getPopulateObjs(profileParamsToPopulate)\n          const profile = userProfileSnap.val()\n          dispatch({\n            type: actionTypes.SET_PROFILE,\n            profile: populate(\n              { profile: token ? { ...profile, token } : profile, data },\n              'profile',\n              populates\n            )\n          })\n        }\n      })\n      .catch((err) => {\n        if (logErrors) {\n          // eslint-disable-next-line no-console\n          console.error(\n            `RRF: Error retrieving data for profile population. Firebase:`,\n            err\n          )\n        }\n        // Error retrieving data for population onto profile.\n        dispatch({\n          type: actionTypes.UNAUTHORIZED_ERROR,\n          authError: `Error during profile population: ${err.message}`\n        })\n        // Update profile with un-populated version\n        dispatch({ type: actionTypes.SET_PROFILE, profile })\n      })\n  }\n}\n\n/**\n * Creates a function for handling errors from profile watcher. Used for\n * both RTDB and Firestore.\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @returns {Function} Profile watch error handler function\n * @private\n */\nfunction createProfileWatchErrorHandler(dispatch, firebase) {\n  const {\n    config: { onProfileListenerError, logErrors }\n  } = firebase._\n  return function handleProfileError(err) {\n    if (logErrors) {\n      // eslint-disable-next-line no-console\n      console.error(`Error with profile listener: ${err.message || ''}`, err)\n    }\n    if (typeof onProfileListenerError === 'function') {\n      const factoryResult = onProfileListenerError(err, firebase)\n      // Return factoryResult if it is a promise\n      if (typeof factoryResult.then === 'function') {\n        return factoryResult\n      }\n    }\n    return Promise.reject(err)\n  }\n}\n\n/**\n * Watch user profile. Internally dispatches sets firebase._.profileWatch\n * and calls SET_PROFILE actions. Supports both Realtime Database and Firestore\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @private\n */\nexport const watchUserProfile = (dispatch, firebase) => {\n  const {\n    authUid,\n    config: { userProfile, useFirestoreForProfile, enableClaims }\n  } = firebase._\n  unWatchUserProfile(firebase)\n\n  if (userProfile) {\n    if (useFirestoreForProfile && firebase.firestore) {\n      firebase._.profileWatch = firebase // eslint-disable-line no-param-reassign\n        .firestore()\n        .collection(userProfile)\n        .doc(authUid)\n        .onSnapshot((userProfileSnap) => {\n          return enableClaims\n            ? firebase\n                .auth()\n                .currentUser.getIdTokenResult(true)\n                .then((token) =>\n                  handleProfileWatchResponse(\n                    dispatch,\n                    firebase,\n                    userProfileSnap,\n                    token\n                  )\n                )\n            : handleProfileWatchResponse(\n                dispatch,\n                firebase,\n                userProfileSnap,\n                null\n              )\n        }, createProfileWatchErrorHandler(dispatch, firebase))\n    } else if (firebase.database) {\n      firebase._.profileWatch = firebase // eslint-disable-line no-param-reassign\n        .database()\n        .ref()\n        .child(`${userProfile}/${authUid}`)\n        .on(\n          'value',\n          (userProfileSnap) => {\n            enableClaims\n              ? firebase\n                  .auth()\n                  .currentUser.getIdTokenResult(true)\n                  .then((token) =>\n                    handleProfileWatchResponse(\n                      dispatch,\n                      firebase,\n                      userProfileSnap,\n                      token\n                    )\n                  )\n              : handleProfileWatchResponse(\n                  dispatch,\n                  firebase,\n                  userProfileSnap,\n                  null\n                )\n          },\n          createProfileWatchErrorHandler(dispatch, firebase)\n        )\n    } else {\n      throw new Error(\n        'Real Time Database or Firestore must be included to enable user profile'\n      )\n    }\n  } else if (enableClaims) {\n    firebase._.profileWatch = firebase\n      .auth()\n      .currentUser.getIdTokenResult(true)\n      .then((token) => {\n        dispatch({\n          type: actionTypes.SET_PROFILE,\n          profile: { token }\n        })\n      })\n  }\n}\n\n/**\n * Create user profile if it does not already exist.\n * `updateProfileOnLogin: false` can be passed to config to disable updating.\n * Profile factory is applied if it exists and is a function.\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} userData - User data object (response from authenticating)\n * @param {object} profile - Profile data to place in new profile\n * @returns {Promise} Resolves after creating user profile\n * @private\n */\nexport const createUserProfile = (dispatch, firebase, userData, profile) => {\n  const {\n    _: { config }\n  } = firebase\n  if (!config.userProfile || (!firebase.database && !firebase.firestore)) {\n    return Promise.resolve(userData)\n  }\n  // use profileFactory if it exists in config\n  if (typeof config.profileFactory === 'function') {\n    // catch errors in user provided profileFactory function\n    try {\n      profile = config.profileFactory(userData, profile, firebase) // eslint-disable-line no-param-reassign\n    } catch (err) {\n      /* eslint-disable no-console */\n      console.error(\n        'Error occurred within profileFactory function:',\n        err.message || err\n      )\n      /* eslint-enable no-console */\n      return Promise.reject(err)\n    }\n  }\n\n  // Check/Write profile using Firestore\n  if (config.useFirestoreForProfile) {\n    // Check for user's profile at userProfile path if provided\n    return firebase\n      .firestore()\n      .collection(config.userProfile)\n      .doc(userData.uid || userData.user.uid)\n      .get()\n      .then((profileSnap) => {\n        // Return if config for updating profile is not enabled and profile exists\n        if (!config.updateProfileOnLogin && profileSnap.exists) {\n          return profileSnap.data()\n        }\n        let newProfile = profile\n\n        // If the user did supply a profileFactory, we should use the result of it for the new Profile\n        if (!newProfile) {\n          // Convert to JSON format (to prevent issue of writing invalid type to Firestore)\n          const userDataObject = userData.uid\n            ? userData.toJSON\n              ? userData.toJSON()\n              : userData\n            : userData.user.toJSON\n            ? userData.user.toJSON()\n            : userData.user\n          // Remove unnecessary auth params (configurable) and preserve types of timestamps\n          newProfile = {\n            ...omit(userDataObject, config.keysToRemoveFromAuth),\n            avatarUrl: userDataObject.photoURL // match profile pattern used for RTDB\n          }\n        }\n\n        // Convert custom object type within Provider data to a normal object\n        if (Array.isArray(newProfile.providerData)) {\n          newProfile.providerData = newProfile.providerData.map(\n            (providerDataItem) =>\n              pick(providerDataItem, config.keysToPreserveFromProviderData)\n          )\n        }\n\n        // Create/Update the profile\n        return profileSnap.ref\n          .set(newProfile, { merge: true })\n          .then(() => newProfile)\n      })\n      .catch((err) => {\n        // Error reading user profile\n        dispatch({ type: actionTypes.UNAUTHORIZED_ERROR, authError: err })\n        return Promise.reject(err)\n      })\n  }\n\n  // Check/Write profile using Firebase RTDB\n  return firebase\n    .database()\n    .ref()\n    .child(\n      `${config.userProfile}/${\n        userData.user ? userData.user.uid : userData.uid\n      }`\n    )\n    .once('value')\n    .then(\n      (profileSnap) =>\n        // update profile only if doesn't exist or if set by config\n        !config.updateProfileOnLogin && profileSnap.val() !== null\n          ? profileSnap.val()\n          : profileSnap.ref.update(profile).then(() => profile) // Update the profile\n    )\n    .catch((err) => {\n      // Error reading user profile\n      dispatch({ type: actionTypes.UNAUTHORIZED_ERROR, authError: err })\n      if (typeof config.onProfileWriteError === 'function') {\n        config.onProfileWriteError(err, firebase)\n      }\n      return Promise.reject(err)\n    })\n}\n\n/**\n * Auth state change handler. Handles response from firebase's onAuthStateChanged\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param  {object} authData - Auth data from firebase's onAuthStateChanged\n * @private\n */\nconst handleAuthStateChange = (dispatch, firebase, authData) => {\n  const { config } = firebase._\n  if (!authData) {\n    // Run onAuthStateChanged if it exists in config and enableEmptyAuthChanges is set to true\n    if (typeof config.onAuthStateChanged === 'function') {\n      firebase._.config.onAuthStateChanged(authData, firebase, dispatch)\n    }\n    dispatch({\n      type: actionTypes.AUTH_EMPTY_CHANGE,\n      preserve: config.preserveOnEmptyAuthChange\n    })\n\n    unWatchUserProfile(firebase)\n  } else {\n    firebase._.authUid = authData.uid // eslint-disable-line no-param-reassign\n\n    // setup presence if settings and database exist\n    if (config.presence) {\n      setupPresence(dispatch, firebase)\n    }\n\n    dispatch({\n      type: actionTypes.LOGIN,\n      auth: authData,\n      preserve: config.preserveOnLogin\n    })\n\n    watchUserProfile(dispatch, firebase)\n\n    // Run onAuthStateChanged if it exists in config\n    if (typeof config.onAuthStateChanged === 'function') {\n      config.onAuthStateChanged(authData, firebase, dispatch)\n    }\n  }\n}\n\n/**\n * Redirect result handler\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param  {object} authData - Auth data from Firebase's getRedirectResult\n * @returns {void}\n * @private\n */\nexport const handleRedirectResult = (dispatch, firebase, authData) => {\n  // Run onRedirectResult if it exists in config\n  if (typeof firebase._.config.onRedirectResult === 'function') {\n    firebase._.config.onRedirectResult(authData, firebase, dispatch)\n  }\n  if (authData && authData.user) {\n    const { user } = authData\n\n    firebase._.authUid = user.uid // eslint-disable-line no-param-reassign\n    watchUserProfile(dispatch, firebase)\n\n    dispatch({\n      type: actionTypes.LOGIN,\n      auth: user,\n      preserve: firebase._.config.preserveOnLogin\n    })\n\n    return createUserProfile(dispatch, firebase, user, {\n      email: user.email,\n      displayName: user.providerData[0].displayName || user.email,\n      avatarUrl: user.providerData[0].photoURL,\n      providerData: user.providerData\n    })\n  }\n}\n\n/**\n * Initialize authentication state change listener that\n * watches user profile and dispatches login action\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @private\n */\nexport const init = (dispatch, firebase) => {\n  // exit if auth does not exist\n  if (!firebase.auth) {\n    return\n  }\n  dispatch({ type: actionTypes.AUTHENTICATION_INIT_STARTED })\n  // Set Auth State listener\n  firebase\n    .auth()\n    .onAuthStateChanged((authData) =>\n      handleAuthStateChange(dispatch, firebase, authData)\n    )\n\n  // set redirect result callback if enableRedirectHandling set to true\n  if (\n    firebase._.config.enableRedirectHandling &&\n    typeof firebase.auth().getRedirectResult === 'function' &&\n    typeof window !== 'undefined' &&\n    window.location &&\n    window.location.protocol &&\n    window.location.protocol.indexOf('http') !== -1\n  ) {\n    firebase\n      .auth()\n      .getRedirectResult()\n      .then((authData) => handleRedirectResult(dispatch, firebase, authData))\n      .catch((error) => {\n        dispatchLoginError(dispatch, error)\n        return Promise.reject(error)\n      })\n  }\n\n  firebase.auth().currentUser // eslint-disable-line no-unused-expressions\n\n  dispatch({ type: actionTypes.AUTHENTICATION_INIT_FINISHED })\n}\n\n/**\n * Login with errors dispatched\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} credentials - Login credentials\n * @param {object} credentials.email - Email to login with (only needed for email login)\n * @param {object} credentials.password - Password to login with (only needed for email login)\n * @param {object} credentials.provider - Provider name such as google, twitter (only needed for 3rd party provider login)\n * @param {object} credentials.type - Popup or redirect (only needed for 3rd party provider login)\n * @param {object} credentials.token - Custom or provider token\n * @param {firebase.auth.AuthCredential} credentials.credential - Custom or provider token\n * @param {Array|string} credentials.scopes - Scopes to add to provider (i.e. email)\n * @returns {Promise} Resolves after user is logged in\n * @private\n */\nexport const login = (dispatch, firebase, credentials) => {\n  if (firebase._.config.resetBeforeLogin) {\n    dispatchLoginError(dispatch, null)\n  }\n\n  const { method, params } = getLoginMethodAndParams(firebase, credentials)\n\n  return firebase\n    .auth()\n    [method](...params)\n    .then((userData) => {\n      // Handle null response from getRedirectResult before redirect has happened\n      if (!userData) return Promise.resolve(null)\n\n      // For email auth return uid (createUser is used for creating a profile)\n      if (\n        [\n          'signInWithEmailAndPassword',\n          'signInAndRetrieveDataWithEmailAndPassword'\n        ].includes(method)\n      ) {\n        return { user: userData }\n      }\n      // TODO: Only call createUserProfile once, and just pass different settings\n\n      // For token auth, the user key doesn't exist. Instead, return the JWT.\n      if (\n        [\n          'signInWithCustomToken',\n          'signInAndRetrieveDataWithCustomToken'\n        ].includes(method)\n      ) {\n        if (!firebase._.config.updateProfileOnLogin) {\n          return { user: userData }\n        }\n        return createUserProfile(\n          dispatch,\n          firebase,\n          userData,\n          credentials.profile\n        )\n      }\n\n      if (method === 'signInWithPhoneNumber') {\n        // Modify confirm method to include profile creation\n        return {\n          ...userData,\n          confirm: (code) =>\n            // Call original confirm\n            userData.confirm(code).then(({ user, additionalUserInfo }) =>\n              createUserProfile(dispatch, firebase, user, {\n                phoneNumber: user.providerData[0].phoneNumber,\n                providerData: user.providerData\n              }).then((profile) => ({ profile, user, additionalUserInfo }))\n            )\n        }\n      }\n\n      // Create profile when logging in with external provider\n      const user = userData.user || userData\n\n      return createUserProfile(\n        dispatch,\n        firebase,\n        user,\n        credentials.profile || {\n          email: user.email,\n          displayName: user.providerData[0].displayName || user.email,\n          avatarUrl: user.providerData[0].photoURL,\n          providerData: user.providerData\n        }\n      ).then((profile) => ({ profile, ...userData }))\n    })\n    .catch((err) => {\n      dispatchLoginError(dispatch, err)\n      return Promise.reject(err)\n    })\n}\n\n/**\n * Reauthenticate with errors dispatched\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} credentials - Login credentials\n * @param {object} credentials.provider - Provider name such as google, twitter (only needed for 3rd party provider login)\n * @param {object} credentials.type - Popup or redirect (only needed for 3rd party provider login)\n * @param {firebase.auth.AuthCredential} credentials.credential - Custom or provider token\n * @param {Array|string} credentials.scopes - Scopes to add to provider (i.e. email)\n * @returns {Promise} Resolves after user is logged in\n * @private\n */\nexport const reauthenticate = (dispatch, firebase, credentials) => {\n  const { method, params } = getReauthenticateMethodAndParams(\n    firebase,\n    credentials\n  )\n\n  return firebase\n    .auth()\n    .currentUser[method](...params)\n    .then((userData) => {\n      // Handle null response from getRedirectResult before redirect has happened\n      if (!userData) return Promise.resolve(null)\n\n      if (method === 'reauthenticateWithPhoneNumber') {\n        // Modify confirm method to include profile creation\n        return {\n          ...userData,\n          confirm: (code) =>\n            // Call original confirm\n            userData.confirm(code).then(({ user, additionalUserInfo }) =>\n              createUserProfile(dispatch, firebase, user, {\n                phoneNumber: user.providerData[0].phoneNumber,\n                providerData: user.providerData\n              }).then((profile) => ({ profile, user, additionalUserInfo }))\n            )\n        }\n      }\n\n      // Create profile when logging in with external provider\n      const user = userData.user || userData\n\n      return createUserProfile(\n        dispatch,\n        firebase,\n        user,\n        credentials.profile || {\n          email: user.email,\n          displayName: user.providerData[0].displayName || user.email,\n          avatarUrl: user.providerData[0].photoURL,\n          providerData: user.providerData\n        }\n      ).then((profile) => ({ profile, ...userData }))\n    })\n    .catch((err) => {\n      dispatchLoginError(dispatch, err, { reauthenticate: true })\n      return Promise.reject(err)\n    })\n}\n\n/**\n * Logout of firebase and dispatch logout event\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @returns {Promise} Resolves after logging out\n * @private\n */\nexport const logout = (dispatch, firebase) => {\n  // detach profile listener before logging out to prevent permission_denied\n  // errors (for more info see #494)\n  unWatchUserProfile(firebase)\n  return firebase\n    .auth()\n    .signOut()\n    .then(() => {\n      const action = {\n        type: actionTypes.LOGOUT\n      }\n      if (firebase._.config.preserveOnLogout) {\n        action.preserve = firebase._.config.preserveOnLogout\n      }\n      dispatch(action)\n      firebase._.authUid = null\n      return firebase\n    })\n}\n\n/**\n * Create a new user in auth and add an account to userProfile root\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} credentials - Login credentials\n * @param {string} credentials.email - Email of user\n * @param {string} credentials.password - Password of new user\n * @param {object} profile - Profile to store in database for new user\n * @returns {Promise} Resolves after user is created\n * @private\n */\nexport const createUser = (\n  dispatch,\n  firebase,\n  { email, password },\n  profile\n) => {\n  dispatchLoginError(dispatch, null)\n\n  if (!email || !password) {\n    const error = new Error('Email and Password are required to create user')\n    dispatchLoginError(dispatch, error)\n    return Promise.reject(error)\n  }\n\n  return firebase\n    .auth()\n    .createUserWithEmailAndPassword(email, password)\n    .then((userData) =>\n      // Login to newly created account flag is not set to false\n      createUserProfile(dispatch, firebase, userData, profile || { email })\n    )\n    .catch((err) => {\n      dispatchLoginError(dispatch, err)\n      return Promise.reject(err)\n    })\n}\n\n/**\n * Send password reset email to provided email\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {string} email - Email to send recovery email to\n * @returns {Promise} Resolves after password reset email is sent\n * @private\n */\nexport const resetPassword = (dispatch, firebase, email) => {\n  dispatchLoginError(dispatch, null)\n  return firebase\n    .auth()\n    .sendPasswordResetEmail(email)\n    .catch((err) => {\n      if (err) {\n        switch (err.code) {\n          case 'auth/user-not-found':\n            dispatchLoginError(dispatch, {\n              ...err,\n              message: 'The specified user account does not exist.'\n            })\n            break\n          default:\n            dispatchLoginError(dispatch, err)\n        }\n        return Promise.reject(err)\n      }\n    })\n}\n\n/**\n * Confirm the password reset with code and password\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {string} code - Email confirmation reset code\n * @param {string} password - Password to set it to\n * @returns {Promise} Resvoles after password reset is confirmed\n * @private\n */\nexport const confirmPasswordReset = (dispatch, firebase, code, password) => {\n  dispatchLoginError(dispatch, null)\n  return firebase\n    .auth()\n    .confirmPasswordReset(code, password)\n    .catch((err) => {\n      if (err) {\n        switch (err.code) {\n          case 'auth/expired-action-code':\n            dispatchLoginError(\n              dispatch,\n              new Error('The action code has expired.')\n            )\n            break\n          case 'auth/invalid-action-code':\n            dispatchLoginError(\n              dispatch,\n              new Error('The action code is invalid.')\n            )\n            break\n          case 'auth/user-disabled':\n            dispatchLoginError(dispatch, new Error('The user is disabled.'))\n            break\n          case 'auth/user-not-found':\n            dispatchLoginError(dispatch, new Error('The user is not found.'))\n            break\n          case 'auth/weak-password':\n            dispatchLoginError(\n              dispatch,\n              new Error('The password is not strong enough.')\n            )\n            break\n          default:\n            dispatchLoginError(dispatch, err)\n        }\n        return Promise.reject(err)\n      }\n    })\n}\n\n/**\n * Verify that password reset code is valid\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {string} code - Password reset code\n * @returns {Promise} email - Email associated with reset code\n * @private\n */\nexport const verifyPasswordResetCode = (dispatch, firebase, code) => {\n  dispatchLoginError(dispatch, null)\n  return firebase\n    .auth()\n    .verifyPasswordResetCode(code)\n    .catch((err) => {\n      if (err) {\n        dispatchLoginError(dispatch, err)\n      }\n      return Promise.reject(err)\n    })\n}\n\n/**\n * Apply a verification code sent via email or other mechanism\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {string} code - Verification code\n * @returns {Promise} Resolves after applying verification code\n * @private\n */\nexport const applyActionCode = (dispatch, firebase, code) => {\n  dispatchLoginError(dispatch, null)\n  return firebase\n    .auth()\n    .applyActionCode(code)\n    .catch((err) => {\n      if (err) {\n        dispatchLoginError(dispatch, err)\n      }\n      return Promise.reject(err)\n    })\n}\n\n/**\n * Update user profile\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} profileUpdate - Update for profile\n * @param {object} options - Options object\n * @returns {Promise} Resolves after updating profile\n * @private\n */\nexport const updateProfile = (dispatch, firebase, profileUpdate, options) => {\n  const {\n    _: { config }\n  } = firebase\n  dispatch({\n    type: actionTypes.PROFILE_UPDATE_START,\n    payload: profileUpdate\n  })\n  // Select update promise type (firebase/firestore) based on config\n  const updatePromise = config.useFirestoreForProfile\n    ? updateProfileOnFirestore\n    : updateProfileOnRTDB\n  return updatePromise(firebase, profileUpdate, options)\n    .then((snap) => {\n      dispatch({\n        type: actionTypes.PROFILE_UPDATE_SUCCESS,\n        payload: config.useFirestoreForProfile ? snap.data() : snap.val()\n      })\n      return snap\n    })\n    .catch((error) => {\n      dispatch({ type: actionTypes.PROFILE_UPDATE_ERROR, error })\n      return Promise.reject(error)\n    })\n}\n\n/**\n * Update Auth Profile Object. Internally calls\n * `firebase.auth().currentUser.updateProfile` as seen [in the firebase docs](https://firebase.google.com/docs/auth/web/manage-users#update_a_users_profile).\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} authUpdate - Update for current user's auth profile\n * @param {boolean} updateInProfile - Whether or not to update in profile as well\n * @returns {Promise} Resolves with results of updating auth\n * @private\n */\nexport const updateAuth = (dispatch, firebase, authUpdate, updateInProfile) => {\n  dispatch({ type: actionTypes.AUTH_UPDATE_START, payload: authUpdate })\n\n  if (!firebase.auth().currentUser) {\n    const error = new Error('User must be logged in to update auth.')\n    dispatch({ type: actionTypes.AUTH_UPDATE_ERROR, payload: error })\n    return Promise.reject(error)\n  }\n\n  return firebase\n    .auth()\n    .currentUser.updateProfile(authUpdate)\n    .then((payload) => {\n      dispatch({\n        type: actionTypes.AUTH_UPDATE_SUCCESS,\n        auth: firebase.auth().currentUser\n      })\n      if (updateInProfile) {\n        return updateProfile(dispatch, firebase, authUpdate)\n      }\n      return payload\n    })\n    .catch((error) => {\n      dispatch({ type: actionTypes.AUTH_UPDATE_ERROR, error })\n      return Promise.reject(error)\n    })\n}\n\n/**\n * Update user's email within Firebase auth and optionally within\n * users's profile. Internally calls `firebase.auth().currentUser.updateEmail`.\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {string} newEmail - Update to be auth object\n * @param {boolean} updateInProfile - Whether or not to update email within\n * user's profile object (stored under path provided to userProfile config)\n * @returns {Promise} Resolves with results of updating email\n * @private\n */\nexport const updateEmail = (dispatch, firebase, newEmail, updateInProfile) => {\n  dispatch({ type: actionTypes.EMAIL_UPDATE_START, payload: newEmail })\n\n  if (!firebase.auth().currentUser) {\n    const error = new Error('User must be logged in to update email.')\n    dispatch({ type: actionTypes.EMAIL_UPDATE_ERROR, error })\n    return Promise.reject(error)\n  }\n\n  return firebase\n    .auth()\n    .currentUser.updateEmail(newEmail)\n    .then((payload) => {\n      dispatch({ type: actionTypes.EMAIL_UPDATE_SUCCESS, payload: newEmail })\n      if (updateInProfile) {\n        return updateProfile(dispatch, firebase, { email: newEmail })\n      }\n      return payload\n    })\n    .catch((error) => {\n      dispatch({ type: actionTypes.EMAIL_UPDATE_ERROR, error })\n      return Promise.reject(error)\n    })\n}\n\n/**\n * Reload Auth state. Internally calls\n * `firebase.auth().currentUser.reload`.\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @returns {Promise} Resolves with auth\n */\nexport const reloadAuth = (dispatch, firebase) => {\n  dispatch({ type: actionTypes.AUTH_RELOAD_START })\n\n  // reject and dispatch error if not logged in\n  if (!firebase.auth().currentUser) {\n    const error = new Error('User must be logged in to reload auth.')\n    dispatch({ type: actionTypes.AUTH_RELOAD_ERROR, error })\n    return Promise.reject(error)\n  }\n\n  return firebase\n    .auth()\n    .currentUser.reload()\n    .then(() => {\n      const auth = firebase.auth().currentUser\n      dispatch({ type: actionTypes.AUTH_RELOAD_SUCCESS, payload: auth })\n      return auth\n    })\n    .catch((error) => {\n      dispatch({ type: actionTypes.AUTH_RELOAD_ERROR, error })\n      return Promise.reject(error)\n    })\n}\n\n/**\n * Links the user account with the given credentials. Internally\n * calls `firebase.auth().currentUser.linkWithCredential`.\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} credential - Credential with which to link user account\n * @returns {Promise} Resolves with auth\n */\nexport const linkWithCredential = (dispatch, firebase, credential) => {\n  dispatch({ type: actionTypes.AUTH_LINK_START })\n\n  // reject and dispatch error if not logged in\n  if (!firebase.auth().currentUser) {\n    const error = new Error('User must be logged in to link with credential.')\n    dispatch({ type: actionTypes.AUTH_LINK_ERROR, error })\n    return Promise.reject(error)\n  }\n\n  return firebase\n    .auth()\n    .currentUser.linkWithCredential(credential)\n    .then((auth) => {\n      dispatch({ type: actionTypes.AUTH_LINK_SUCCESS, payload: auth })\n      return auth\n    })\n    .catch((error) => {\n      dispatch({ type: actionTypes.AUTH_LINK_ERROR, error })\n      return Promise.reject(error)\n    })\n}\n\n/**\n * @param {Function} promiseFunc - Promise function\n * @param {Array} args - arguments to pass to function\n * @param {Function} dispatch - Redux dispatch function\n * @param {object} firebase - Internal firebase object\n * @returns {Promise} Resolves after auth is linked and AUTH_LINK_SUCCESS\n * action is dispatched\n */\nfunction linkWithAuthDispatch(promiseFunc, args, dispatch, firebase) {\n  dispatch({ type: actionTypes.AUTH_LINK_START })\n\n  // reject and dispatch error if not logged in\n  if (!firebase.auth().currentUser) {\n    const error = new Error('User must be logged in to link with credential.')\n    dispatch({ type: actionTypes.AUTH_LINK_ERROR, error })\n    return Promise.reject(error)\n  }\n\n  return promiseFunc(...args)\n    .then((auth) => {\n      dispatch({ type: actionTypes.AUTH_LINK_SUCCESS, payload: auth })\n      return auth\n    })\n    .catch((error) => {\n      dispatch({ type: actionTypes.AUTH_LINK_ERROR, error })\n      return Promise.reject(error)\n    })\n}\n\n/**\n * Links the user account with the given credentials. Internally\n * calls `firebase.auth().currentUser.linkAndRetrieveDataWithCredential`.\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} credential - Credential with which to link user account\n * @returns {Promise} Resolves with auth\n */\nexport function linkAndRetrieveDataWithCredential(\n  dispatch,\n  firebase,\n  credential\n) {\n  return linkWithAuthDispatch(\n    firebase.auth().currentUser.linkAndRetrieveDataWithCredential,\n    [credential],\n    dispatch,\n    firebase\n  )\n}\n\n/**\n * Links the user account with the given credentials. Internally\n * calls `firebase.auth().currentUser.linkWithPopup`.\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} credential - Credential with which to link user account\n * @returns {Promise} Resolves with auth\n */\nexport function linkWithPopup(dispatch, firebase, credential) {\n  return linkWithAuthDispatch(\n    firebase.auth().currentUser.linkWithPopup,\n    [credential],\n    dispatch,\n    firebase\n  )\n}\n\n/**\n * Links the user account with the given credentials. Internally\n * calls `firebase.auth().currentUser.linkWithRedirect`.\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {any} provider - Auth provider\n * @returns {Promise} Resolves with auth\n */\nexport function linkWithRedirect(dispatch, firebase, provider) {\n  return linkWithAuthDispatch(\n    firebase.auth().currentUser.linkWithRedirect,\n    [provider],\n    dispatch,\n    firebase\n  )\n}\n\n/**\n * Asynchronously signs in using a phone number and create's\n * user profile. This method sends a code via SMS to the given phone\n * number, and returns a firebase.auth.ConfirmationResult. Internally\n * calls `firebase.auth().signInWithPhoneNumber`.\n * @param {object} firebase - Internal firebase object\n * @param {Function} dispatch - Action dispatch function\n * @param {string} phoneNumber - Phone number\n * @param {object} applicationVerifier - Phone number\n * @param {object} options - Options object\n * @returns {Promise} Resolves with auth\n */\nexport function signInWithPhoneNumber(\n  firebase,\n  dispatch,\n  phoneNumber,\n  applicationVerifier,\n  options = {}\n) {\n  return login(dispatch, firebase, {\n    phoneNumber,\n    applicationVerifier,\n    ...options\n  })\n}\n"]},"metadata":{},"sourceType":"script"}